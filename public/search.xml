<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 76. Minimum Window Substring</title>
      <link href="/2021/09/19/LeetCode%2076.%20Minimum%20Window%20Substring/"/>
      <url>/2021/09/19/LeetCode%2076.%20Minimum%20Window%20Substring/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of</em> <code>s</code> <em>such that every character in</em> <code>t</code> <em>(<strong>including duplicates</strong>) is included in the window. If there is no such substring</em><em>, return the empty string</em> <code>&quot;&quot;</code><em>.</em></p><p>The testcases will be generated such that the answer is <strong>unique</strong>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><a href="https://leetcode.com/problems/minimum-window-substring/">https://leetcode.com/problems/minimum-window-substring/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            map[c] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> count = t.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>; right&lt;s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            map[c]--;</span><br><span class="line">            <span class="keyword">if</span>(map[c]&gt;=<span class="number">0</span>) count--;</span><br><span class="line">            <span class="comment">//count = 0, 第一个适配的找到啦</span></span><br><span class="line">            <span class="comment">//缩减范围</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span> lc = s.charAt(left);</span><br><span class="line">                map[lc]++;</span><br><span class="line">                <span class="comment">//目标种的一个出了窗口</span></span><br><span class="line">                <span class="keyword">if</span> (map[lc]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (right-left+<span class="number">1</span>&lt;len) &#123;</span><br><span class="line">                        begin = left;</span><br><span class="line">                        len = right-left+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len==Integer.MAX_VALUE?<span class="string">&quot;&quot;</span>:s.substring(begin, begin+len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O( n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 3. Longest Substring Without Repeating Characters</title>
      <link href="/2021/09/18/LeetCode%203.%20Longest%20Substring%20Without%20Repeating%20Characters/"/>
      <url>/2021/09/18/LeetCode%203.%20Longest%20Substring%20Without%20Repeating%20Characters/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//左指针将重复元素移除</span></span><br><span class="line">            <span class="keyword">while</span> (!set.add(c)) set.remove(s.charAt(left++));</span><br><span class="line">            res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O( n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 11. Container With Most Water</title>
      <link href="/2021/09/17/LeetCode%2011.%20Container%20With%20Most%20Water/"/>
      <url>/2021/09/17/LeetCode%2011.%20Container%20With%20Most%20Water/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given <code>n</code> non-negative integers <code>a1, a2, ..., an</code> , where each represents a point at coordinate <code>(i, ai)</code>. <code>n</code> vertical lines are drawn such that the two endpoints of the line <code>i</code> is at <code>(i, ai)</code> and <code>(i, 0)</code>. Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.</p><p><strong>Notice</strong> that you may not slant the container.</p><p><a href="https://leetcode.com/problems/container-with-most-water/">https://leetcode.com/problems/container-with-most-water/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            area = Math.max(area, (right - left) * Math.min(height[left], height[right]));</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; height[right]) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (height[left] &lt; height[right]) left++;</span><br><span class="line">            <span class="comment">//left = right</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O( n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 16. 3Sum Closest</title>
      <link href="/2021/09/16/LeetCode%2016.%203Sum%20Closest/"/>
      <url>/2021/09/16/LeetCode%2016.%203Sum%20Closest/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> of length <code>n</code> and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>.</p><p>Return <em>the sum of the three integers</em>.</p><p>You may assume that each input would have exactly one solution.</p><p><a href="https://leetcode.com/problems/3sum-closest/">https://leetcode.com/problems/3sum-closest/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> target;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> delta = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] - target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">int</span> newDelta = nums[i] + nums[start] + nums[end] - target;</span><br><span class="line">                <span class="keyword">if</span> (newDelta == <span class="number">0</span>) <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(newDelta) &lt; Math.abs(delta)) delta = newDelta;</span><br><span class="line">                <span class="keyword">if</span> (newDelta &lt; <span class="number">0</span>) start++;</span><br><span class="line">                <span class="keyword">else</span> end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target + delta;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O( n^2)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 15. 3Sum</title>
      <link href="/2021/09/15/LeetCode%2015.%203Sum/"/>
      <url>/2021/09/15/LeetCode%2015.%203Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p><a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> base = nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = base + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    list.add(base);</span><br><span class="line">                    list.add(nums[left]);</span><br><span class="line">                    list.add(nums[right]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                    left = moveRight(nums, left + <span class="number">1</span>);</span><br><span class="line">                    right = moveLeft(nums, right - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right = moveLeft(nums, right - <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = moveRight(nums, left + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = moveRight(nums, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveLeft</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (right == nums.length - <span class="number">1</span> || (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveRight</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left == <span class="number">0</span> || (left &lt; nums.length &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O( n^2)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Two point </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 278. First Bad Version</title>
      <link href="/2021/09/14/LeetCode%20278.%20First%20Bad%20Version/"/>
      <url>/2021/09/14/LeetCode%20278.%20First%20Bad%20Version/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><p><a href="https://leetcode.com/problems/first-bad-version/">https://leetcode.com/problems/first-bad-version/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (!isBadVersion(mid)) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(logn)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Binary search </category>
          
      </categories>
      
      
        <tags>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 48. Rotate Image</title>
      <link href="/2021/09/13/LeetCode%2048.%20Rotate%20Image/"/>
      <url>/2021/09/13/LeetCode%2048.%20Rotate%20Image/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given an <code>n x n</code> 2D <code>matrix</code> representing an image, rotate the image by <strong>90</strong> degrees (clockwise).</p><p>You have to rotate the image <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a>, which means you have to modify the input 2D matrix directly. <strong>DO NOT</strong> allocate another 2D matrix and do the rotation.</p><p><a href="https://leetcode.com/problems/rotate-image/">https://leetcode.com/problems/rotate-image/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[top][left + i];</span><br><span class="line">                matrix[top][left + i] = matrix[bottom - i][left];</span><br><span class="line">                matrix[bottom - i][left] = matrix[bottom][right - i];</span><br><span class="line">                matrix[bottom][right - i] = matrix[top + i][right];</span><br><span class="line">                matrix[top + i][right] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            n -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n^2)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2D array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 41. First Missing Positive</title>
      <link href="/2021/09/12/LeetCode%2041.%20First%20Missing%20Positive/"/>
      <url>/2021/09/12/LeetCode%2041.%20First%20Missing%20Positive/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an unsorted integer array <code>nums</code>, return the smallest missing positive integer.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses constant extra space.</p><p><a href="https://leetcode.com/problems/first-missing-positiv">https://leetcode.com/problems/first-missing-positiv</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//3142</span></span><br><span class="line">            <span class="comment">//31-42</span></span><br><span class="line">            <span class="keyword">int</span> num = Math.abs(nums[i]);</span><br><span class="line">            <span class="comment">//3642</span></span><br><span class="line">            <span class="comment">//最大是5，不需要操作，两个重要的点</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= nums.length) &#123;</span><br><span class="line">                nums[num - <span class="number">1</span>] = -Math.abs(nums[num - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 41. First Missing Positive</title>
      <link href="/2021/09/12/LeetCode%2049.%20Group%20Anagrams/"/>
      <url>/2021/09/12/LeetCode%2049.%20Group%20Anagrams/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p><p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p><a href="https://leetcode.com/problems/group-anagrams/">https://leetcode.com/problems/group-anagrams/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        ArrayList&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] curr = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(curr);</span><br><span class="line">            String key = String.valueOf(curr);</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(key))</span><br><span class="line">                map.put(key, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 31. Next Permutation</title>
      <link href="/2021/09/11/LeetCode%2031.%20Next%20Permutation/"/>
      <url>/2021/09/11/LeetCode%2031.%20Next%20Permutation/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p><p>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm">in place</a></strong> and use only constant extra memory.</p><p><a href="https://leetcode.com/problems/next-permutation/">https://leetcode.com/problems/next-permutation/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> replace = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//后面的数确定是倒序排列的</span></span><br><span class="line">        <span class="keyword">while</span> (replace &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[replace] &lt; nums[replace + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            replace--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (replace &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lgrIdx = replace + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//while 找到的是最接近的比replace位大的数的下一位</span></span><br><span class="line">        <span class="keyword">while</span> (lgrIdx &lt; nums.length &amp;&amp; nums[lgrIdx] &gt; nums[replace]) &#123;</span><br><span class="line">            lgrIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[replace];</span><br><span class="line">        nums[replace] = nums[lgrIdx - <span class="number">1</span>];</span><br><span class="line">        nums[lgrIdx - <span class="number">1</span>] = tmp;</span><br><span class="line">        <span class="comment">//nums.length不参加排序</span></span><br><span class="line">        Arrays.sort(nums, replace + <span class="number">1</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(nlogn)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 59. Spiral Matrix II</title>
      <link href="/2021/09/10/LeetCode%2059.%20Spiral%20Matrix%20II/"/>
      <url>/2021/09/10/LeetCode%2059.%20Spiral%20Matrix%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a positive integer <code>n</code>, generate an <code>n x n</code> <code>matrix</code> filled with elements from <code>1</code> to <code>n2</code> in spiral order.</p><p><a href="https://leetcode.com/problems/spiral-matrix-ii/">https://leetcode.com/problems/spiral-matrix-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (top &lt; bottom &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) res[top][i] = k++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt; bottom; i++) res[i][right] = k++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--) res[bottom][i] = k++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt; top; i--) res[i][left] = k++;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n %<span class="number">2</span> != <span class="number">0</span>) res[n / <span class="number">2</span>][n / <span class="number">2</span>] = k;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(mn)</p><p>Space complexity: O(mn)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2D array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 54. Spiral Matrix</title>
      <link href="/2021/09/09/LeetCode%2054.%20Spiral%20Matrix/"/>
      <url>/2021/09/09/LeetCode%2054.%20Spiral%20Matrix/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an <code>m x n</code> <code>matrix</code>, return <em>all elements of the</em> <code>matrix</code> <em>in spiral order</em>.</p><p><a href="https://leetcode.com/problems/spiral-matrix/">https://leetcode.com/problems/spiral-matrix/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; i++) res.add(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt; bottom; i++) res.add(matrix[i][right]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; i--) res.add(matrix[bottom][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom; i &gt; top; i--) res.add(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &lt;= bottom; i++) res.add(matrix[i][left]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (top == bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) res.add(matrix[top][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(mn)</p><p>Space complexity: O(mn)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2D array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 621. Task Scheduler</title>
      <link href="/2021/09/08/LeetCode%20621.%20Task%20Scheduler/"/>
      <url>/2021/09/08/LeetCode%20621.%20Task%20Scheduler/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a characters array <code>tasks</code>, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. For each unit of time, the CPU could complete either one task or just be idle.</p><p>However, there is a non-negative integer <code>n</code> that represents the cooldown period between two <strong>same tasks</strong> (the same letter in the array), that is that there must be at least <code>n</code> units of time between any two same tasks.</p><p>Return <em>the least number of units of times that the CPU will take to finish all the given tasks</em>.</p><p><a href="https://leetcode.com/problems/task-scheduler/">https://leetcode.com/problems/task-scheduler/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> a : tasks)&#123;</span><br><span class="line">            record[a-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(record);</span><br><span class="line">        <span class="keyword">int</span> max_n = record[<span class="number">25</span>]-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> space = max_n* n;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">24</span>; i &gt;=<span class="number">0</span>&amp;&amp; record[i]&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            space -= Math.min(max_n,record[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> space&gt;<span class="number">0</span>?tasks.length+space:tasks.length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 283. Move Zeroes</title>
      <link href="/2021/09/07/LeetCode%20283.%20Move%20Zeroes/"/>
      <url>/2021/09/07/LeetCode%20283.%20Move%20Zeroes/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code>, move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p><p><a href="https://leetcode.com/problems/move-zeroes/">https://leetcode.com/problems/move-zeroes/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> insertPos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != <span class="number">0</span>) nums[insertPos++] = num;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (insertPos &lt; nums.length) &#123;</span><br><span class="line">        nums[insertPos++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. Reverse String</title>
      <link href="/2021/09/06/LeetCode%2026.%20Remove%20Duplicates%20from%20Sorted%20Array/"/>
      <url>/2021/09/06/LeetCode%2026.%20Remove%20Duplicates%20from%20Sorted%20Array/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> sorted in <strong>non-decreasing order</strong>, remove the duplicates <a href="https://en.wikipedia.org/wiki/In-place_algorithm"><strong>in-place</strong></a> such that each unique element appears only <strong>once</strong>. The <strong>relative order</strong> of the elements should be kept the <strong>same</strong>.</p><p>Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the <strong>first part</strong> of the array <code>nums</code>. More formally, if there are <code>k</code> elements after removing the duplicates, then the first <code>k</code> elements of <code>nums</code> should hold the final result. It does not matter what you leave beyond the first <code>k</code> elements.</p><p>Return <code>k</code> <em>after placing the final result in the first</em> <code>k</code> <em>slots of</em> <code>nums</code>.</p><p>Do <strong>not</strong> allocate extra space for another array. You must do this by <strong>modifying the input array <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> with O(1) extra memory.</p><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">https://leetcode.com/problems/remove-duplicates-from-sorted-array/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//slow 是下一个要放的位置，比index大1，所以return时不需要加1</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast - <span class="number">1</span>] != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Array </category>
          
      </categories>
      
      
        <tags>
            
            <tag> two point </tag>
            
            <tag> remove duplicates </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 344. Reverse String</title>
      <link href="/2021/09/06/LeetCode%20344.%20Reverse%20String/"/>
      <url>/2021/09/06/LeetCode%20344.%20Reverse%20String/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p><p><a href="https://leetcode.com/problems/reverse-string/">https://leetcode.com/problems/reverse-string/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = tmp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> String </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> reserve string </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 215. Kth Largest Element in an Array</title>
      <link href="/2021/09/05/LeetCode%20215.%20Kth%20Largest%20Element%20in%20an%20Array/"/>
      <url>/2021/09/05/LeetCode%20215.%20Kth%20Largest%20Element%20in%20an%20Array/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>kth</code> <em>largest element in the array</em>.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//shuffle(nums);</span></span><br><span class="line">        <span class="comment">//divide(nums, 0, nums.length - 1, k);</span></span><br><span class="line">        <span class="comment">//return nums[nums.length - k];</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &lt; k || x &gt;= heap.peek())&#123;</span><br><span class="line">                heap.offer(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(nlog(k))</p><p>Space complexity: O(k)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Heap </tag>
            
            <tag> PriorityQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 560. Subarray Sum Equals K</title>
      <link href="/2021/09/04/LeetCode%20560.%20Subarray%20Sum%20Equals%20K/"/>
      <url>/2021/09/04/LeetCode%20560.%20Subarray%20Sum%20Equals%20K/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of integers <code>nums</code> and an integer <code>k</code>, return <em>the total number of continuous subarrays whose sum equals to <code>k</code></em>.</p><p><a href="https://leetcode.com/problems/subarray-sum-equals-k/">https://leetcode.com/problems/subarray-sum-equals-k/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) res += map.get(sum - k);</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> HashMap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> subarray sum </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 138. Copy List with Random Pointer</title>
      <link href="/2021/09/03/LeetCode%20138.%20Copy%20List%20with%20Random%20Pointer/"/>
      <url>/2021/09/03/LeetCode%20138.%20Copy%20List%20with%20Random%20Pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p><p>Construct a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p><p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Node cur = head; cur != <span class="keyword">null</span>; cur = cur.next)</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">        <span class="keyword">for</span> (Node cur = head; cur != <span class="keyword">null</span>; cur = cur.next)&#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> copy linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 160. Intersection of Two Linked Lists</title>
      <link href="/2021/09/02/LeetCode%20160.%20Intersection%20of%20Two%20Linked%20Lists/"/>
      <url>/2021/09/02/LeetCode%20160.%20Intersection%20of%20Two%20Linked%20Lists/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the heads of two singly linked-lists <code>headA</code> and <code>headB</code>, return <em>the node at which the two lists intersect</em>. If the two linked lists have no intersection at all, return <code>null</code>.</p><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> detect cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 234. Palindrome Linked List</title>
      <link href="/2021/09/01/LeetCode%20234.%20Palindrome%20Linked%20List/"/>
      <url>/2021/09/01/LeetCode%20234.%20Palindrome%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome.</p><p><a href="https://leetcode.com/problems/palindrome-linked-list/">https://leetcode.com/problems/palindrome-linked-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123; <span class="comment">// odd nodes: let right half smaller</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow = reverse(slow);</span><br><span class="line">    fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.val != slow.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> palindrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1171. Remove Zero Sum Consecutive Nodes from Linked List</title>
      <link href="/2021/08/31/LeetCode%201171.%20Remove%20Zero%20Sum%20Consecutive%20Nodes%20from%20Linked%20List/"/>
      <url>/2021/08/31/LeetCode%201171.%20Remove%20Zero%20Sum%20Consecutive%20Nodes%20from%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a linked list, we repeatedly delete consecutive sequences of nodes that sum to <code>0</code> until there are no such sequences.</p><p>After doing so, return the head of the final linked list. You may return any such answer.</p><p>(Note that in the examples below, all sequences are serializations of <code>ListNode</code> objects.)</p><p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/">https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeZeroSumSublists</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preFix = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        Map&lt;Integer, ListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, dummy);</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = dummy; i != <span class="keyword">null</span>; i= i.next)&#123;</span><br><span class="line">            preFix += i.val;</span><br><span class="line">            map.put(preFix, i);</span><br><span class="line">        &#125;</span><br><span class="line">        preFix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode i = dummy; i != <span class="keyword">null</span>; i = i.next)&#123;</span><br><span class="line">            preFix += i.val;</span><br><span class="line">            i.next = map.get(preFix).next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
            <tag> prefix sum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 19. Remove Nth Node From End of List</title>
      <link href="/2021/08/30/LeetCode%2019.%20Remove%20Nth%20Node%20From%20End%20of%20List/"/>
      <url>/2021/08/30/LeetCode%2019.%20Remove%20Nth%20Node%20From%20End%20of%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a linked list, remove the <code>nth</code> node from the end of the list and return its head.</p><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode first = dummy, second = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line">            first = first.next;</span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next = second.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 82. Remove Duplicates from Sorted List II</title>
      <link href="/2021/08/29/LeetCode%2082.%20Remove%20Duplicates%20from%20Sorted%20List%20II/"/>
      <url>/2021/08/29/LeetCode%2082.%20Remove%20Duplicates%20from%20Sorted%20List%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a sorted linked list, <em>delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy, cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = cur.val;</span><br><span class="line">                <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; temp == cur.val) cur = cur.next;</span><br><span class="line">                pre.next = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 83. Remove Duplicates from Sorted List</title>
      <link href="/2021/08/28/LeetCode%2082.%20Remove%20Duplicates%20from%20Sorted%20List/"/>
      <url>/2021/08/28/LeetCode%2082.%20Remove%20Duplicates%20from%20Sorted%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 83. Remove Duplicates from Sorted List</title>
      <link href="/2021/08/28/LeetCode%2083.%20Remove%20Duplicates%20from%20Sorted%20List/"/>
      <url>/2021/08/28/LeetCode%2083.%20Remove%20Duplicates%20from%20Sorted%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a sorted linked list, <em>delete all duplicates such that each element appears only once</em>. Return <em>the linked list <strong>sorted</strong> as well</em>.</p><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 203. Remove Linked List Elements</title>
      <link href="/2021/08/27/LeetCode%20203.%20Remove%20Linked%20List%20Elements/"/>
      <url>/2021/08/27/LeetCode%20203.%20Remove%20Linked%20List%20Elements/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a linked list and an integer <code>val</code>, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return <em>the new head</em>.</p><p><a href="https://leetcode.com/problems/remove-linked-list-elements/">https://leetcode.com/problems/remove-linked-list-elements/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) cur.next = cur.next.next;</span><br><span class="line">            <span class="keyword">else</span> cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> remove linked list node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 287. Find the Duplicate Number</title>
      <link href="/2021/08/26/LeetCode%20287.%20Find%20the%20Duplicate%20Number/"/>
      <url>/2021/08/26/LeetCode%20287.%20Find%20the%20Duplicate%20Number/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p><p><a href="https://leetcode.com/problems/find-the-duplicate-number/">https://leetcode.com/problems/find-the-duplicate-number/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//for(int num : nums)</span></span><br><span class="line">        <span class="comment">//    if(!seen.add(num)) return num;</span></span><br><span class="line">        <span class="comment">//return -1;</span></span><br><span class="line">        <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                fast = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">                    slow = nums[slow];</span><br><span class="line">                    fast = nums[fast];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> detect cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 142. Linked List Cycle II</title>
      <link href="/2021/08/25/LeetCode%20142.%20Linked%20List%20Cycle%20II/"/>
      <url>/2021/08/25/LeetCode%20142.%20Linked%20List%20Cycle%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins. If there is no cycle, return</em> <code>null</code>.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that</strong> <code>pos</code> <strong>is not passed as a parameter</strong>.</p><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> detect cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 141. Linked List Cycle</title>
      <link href="/2021/08/24/LeetCode%20141.%20Linked%20List%20Cycle/"/>
      <url>/2021/08/24/LeetCode%20141.%20Linked%20List%20Cycle/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p><p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p><p><a href="https://leetcode.com/problems/linked-list-cycle/">https://leetcode.com/problems/linked-list-cycle/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> detect cycle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 23. Merge k Sorted Lists</title>
      <link href="/2021/08/23/LeetCode%2023.%20Merge%20k%20Sorted%20Lists/"/>
      <url>/2021/08/23/LeetCode%2023.%20Merge%20k%20Sorted%20Lists/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/">https://leetcode.com/problems/merge-k-sorted-lists/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//pq,time O(nlogk), space O(K)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) pq.offer(lists[i]);<span class="comment">//only first element will be insert to the pq</span></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            cur.next = pq.poll();</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (pq.isEmpty()) <span class="keyword">break</span>; <span class="comment">//last cycle dont need work</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) pq.offer(cur.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(nklogk)</p><p>Space complexity: O(k)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> merge lists </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 21. Merge Two Sorted Lists</title>
      <link href="/2021/08/22/LeetCode%2021.%20Merge%20Two%20Sorted%20Lists/"/>
      <url>/2021/08/22/LeetCode%2021.%20Merge%20Two%20Sorted%20Lists/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Merge two sorted linked lists and return it as a <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">https://leetcode.com/problems/merge-two-sorted-lists/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt; l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 == <span class="keyword">null</span> ? l2: l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> merge lists </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 445. Add Two Numbers II</title>
      <link href="/2021/08/21/LeetCode%20445.%20Add%20Two%20Numbers%20II/"/>
      <url>/2021/08/21/LeetCode%20445.%20Add%20Two%20Numbers%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><a href="https://leetcode.com/problems/add-two-numbers-ii/">https://leetcode.com/problems/add-two-numbers-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2= l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty() || !stack2.isEmpty() || carry != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            <span class="keyword">int</span> val2 = stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="keyword">int</span> sum = val1 + val2 + carry;</span><br><span class="line">            ListNode cur = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur.next = res;</span><br><span class="line">            res = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> add two numbers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 2. Add Two Numbers</title>
      <link href="/2021/08/20/LeetCode%202.%20Add%20Two%20Numbers/"/>
      <url>/2021/08/20/LeetCode%202.%20Add%20Two%20Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><a href="https://leetcode.com/problems/add-two-numbers/">https://leetcode.com/problems/add-two-numbers/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span> || l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) cur.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> add two numbers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 25. Reverse Nodes in k-Group</title>
      <link href="/2021/08/19/LeetCode%2025.%20Reverse%20Nodes%20in%20k-Group/"/>
      <url>/2021/08/19/LeetCode%2025.%20Reverse%20Nodes%20in%20k-Group/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes, in the end, should remain as it is.</p><p>You may not alter the values in the list’s nodes, only nodes themselves may be changed.</p><p><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Save the previous reversed pointer in prev </span></span><br><span class="line">        <span class="comment">//and in wach iteration use prev.next to set the previous ptr </span></span><br><span class="line">        <span class="comment">//to the current reversed.</span></span><br><span class="line">        ListNode tempNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        tempNode.next = head;</span><br><span class="line">        ListNode tempHead = head;</span><br><span class="line">        ListNode prev = tempNode;</span><br><span class="line">        <span class="keyword">while</span>(tempHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// Starting of each reversed list, </span></span><br><span class="line">            <span class="comment">//it will become the last after reversing</span></span><br><span class="line">            ListNode klast = tempHead;</span><br><span class="line">            <span class="keyword">int</span> num = k;</span><br><span class="line">            <span class="comment">// Jump k </span></span><br><span class="line">            <span class="keyword">while</span>(num&gt;<span class="number">0</span> &amp;&amp; tempHead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                tempHead = tempHead.next;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If cannot reverse</span></span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">0</span>) &#123;</span><br><span class="line">                prev.next = klast;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// start of each reversed group</span></span><br><span class="line">            ListNode kstart = reverse(klast,k);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Use previous&#x27;s next to point to curr reversed</span></span><br><span class="line">            prev.next = kstart;</span><br><span class="line">            <span class="comment">// Set prev to current rev end.</span></span><br><span class="line">            prev = klast; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempNode.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Standard reverse code</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span> &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 206. Reverse Linked List</title>
      <link href="/2021/08/18/LeetCode%20206.%20Reverse%20Linked%20List/"/>
      <url>/2021/08/18/LeetCode%20206.%20Reverse%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p><p><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 92. Reverse Linked List II</title>
      <link href="/2021/08/18/LeetCode%2092.%20Reverse%20Linked%20List%20II/"/>
      <url>/2021/08/18/LeetCode%2092.%20Reverse%20Linked%20List%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>head</code> of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position <code>left</code> to position <code>right</code>, and return <em>the reversed list</em>.</p><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">https://leetcode.com/problems/reverse-linked-list-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode fakeHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        fakeHead.next = head;</span><br><span class="line">        ListNode prev = fakeHead;</span><br><span class="line">        ListNode cur = fakeHead.next;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; left)&#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = prev;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt;= right)&#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next.next = cur;</span><br><span class="line">        node.next = prev;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Linked List </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse Linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 77. Combinations</title>
      <link href="/2021/08/17/LeetCode%2077.%20Combinations/"/>
      <url>/2021/08/17/LeetCode%2077.%20Combinations/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two integers <code>n</code> and <code>k</code>, return <em>all possible combinations of</em> <code>k</code> <em>numbers out of the range</em> <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p><a href="https://leetcode.com/problems/combinations">https://leetcode.com/problems/combinations</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; level, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level.size() == k) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(level));</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt;= n; i++)&#123;</span><br><span class="line">                level.add(i);</span><br><span class="line">                dfs(res, level, n, k, i + <span class="number">1</span>);</span><br><span class="line">                level.remove(level.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(C(n, k))</p><p>Space complexity: O(k)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 131. Palindrome Partitioning</title>
      <link href="/2021/08/16/LeetCode%20131.%20Palindrome%20Partitioning/"/>
      <url>/2021/08/16/LeetCode%20131.%20Palindrome%20Partitioning/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return all possible palindrome partitioning of <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><a href="https://leetcode.com/problems/palindrome-partitioning/">https://leetcode.com/problems/palindrome-partitioning/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">   List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), s, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;String&gt;&gt; list, List&lt;String&gt; tempList, String s, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(start == s.length())</span><br><span class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; s.length(); i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">            tempList.add(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">            backtrack(list, tempList, s, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">      <span class="keyword">if</span>(s.charAt(low++) != s.charAt(high--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(n*2^n), T(n) = 2T(n-1) + P(n)</span></span><br><span class="line"><span class="comment">    Space: O(n*2^n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n*2^n)</p><p>Space complexity: O(n*2^n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 40. Combination Sum II</title>
      <link href="/2021/08/15/LeetCode%2040.%20Combination%20Sum%20II/"/>
      <url>/2021/08/15/LeetCode%2040.%20Combination%20Sum%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p><p><a href="https://leetcode.com/problems/combination-sum-ii/">https://leetcode.com/problems/combination-sum-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, remain - nums[i], i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(k * C(n, k)), O(n*2^n)</span></span><br><span class="line"><span class="comment">    Space: O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n*2^n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 39. Combination Sum</title>
      <link href="/2021/08/14/LeetCode%2039.%20Combination%20Sum/"/>
      <url>/2021/08/14/LeetCode%2039.%20Combination%20Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code><em>.</em> You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p>It is <strong>guaranteed</strong> that the number of unique combinations that sum up to <code>target</code> is less than <code>150</code> combinations for the given input.</p><p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, target, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> remain, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(remain &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(remain == <span class="number">0</span>) list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">                tempList.add(nums[i]);</span><br><span class="line">                backtrack(list, tempList, nums, remain - nums[i], i); <span class="comment">// not i + 1 because we can reuse same elements</span></span><br><span class="line">                tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(k * C(n, k))， O(n*2^n)</span></span><br><span class="line"><span class="comment">    Space: O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n*2^n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 47. Permutations II</title>
      <link href="/2021/08/13/LeetCode%2047.%20Permutations%20II/"/>
      <url>/2021/08/13/LeetCode%2047.%20Permutations%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a collection of numbers, <code>nums</code>, that might contain duplicates, return <em>all possible unique permutations <strong>in any order</strong>.</em></p><p><a href="https://leetcode.com/problems/permutations-ii/">https://leetcode.com/problems/permutations-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(list, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">boolean</span> [] used)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="keyword">true</span>; </span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, used);</span><br><span class="line">            used[i] = <span class="keyword">false</span>; </span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(N!)</span></span><br><span class="line"><span class="comment">    Space: O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(N!)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 46. Permutations</title>
      <link href="/2021/08/12/LeetCode%2046.%20Permutations/"/>
      <url>/2021/08/12/LeetCode%2046.%20Permutations/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array <code>nums</code> of distinct integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><a href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// Arrays.sort(nums); // not necessary</span></span><br><span class="line">   backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(tempList.size() == nums.length)&#123;</span><br><span class="line">      list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123; </span><br><span class="line">         <span class="keyword">if</span>(tempList.contains(nums[i])) <span class="keyword">continue</span>; <span class="comment">// element already exists, skip</span></span><br><span class="line">         tempList.add(nums[i]);</span><br><span class="line">         backtrack(list, tempList, nums);</span><br><span class="line">         tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(N!),T(n) = n( c1 + T(n-1) )</span></span><br><span class="line"><span class="comment">    Space: O(N)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(N!)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 90. Subsets II</title>
      <link href="/2021/08/11/LeetCode%2090.%20Subsets%20II/"/>
      <url>/2021/08/11/LeetCode%2090.%20Subsets%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> that may contain duplicates, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><a href="https://leetcode.com/problems/subsets-ii/">https://leetcode.com/problems/subsets-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Time: O(n * 2^n) 解的个数*每个解的时间复杂度</span></span><br><span class="line"><span class="comment">    Space: O(n) 额外的数组保存中甲结果</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n*2^n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 78. Subsets</title>
      <link href="/2021/08/10/LeetCode%2078.%20Subsets/"/>
      <url>/2021/08/10/LeetCode%2078.%20Subsets/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Arrays.sort(nums); 不重复没必要sort</span></span><br><span class="line">    backtrack(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">        tempList.add(nums[i]);</span><br><span class="line">        backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">        tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n*2^n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Backtracking </category>
          
      </categories>
      
      
        <tags>
            
            <tag> backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 117. Populating Next Right Pointers in Each Node II</title>
      <link href="/2021/08/09/LeetCode%20117.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/"/>
      <url>/2021/08/09/LeetCode%20117.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary tree</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">      Node dummyHead  = <span class="keyword">new</span> Node(<span class="number">0</span>); <span class="comment">// this head will always point to the first element in the current layer we are searching</span></span><br><span class="line">      Node pre = dummyHead; <span class="comment">// this &#x27;pre&#x27; will be the &quot;current node&quot; that builds every single layer   </span></span><br><span class="line">      Node real_root = root; <span class="comment">// just for return statement</span></span><br><span class="line">        </span><br><span class="line">      <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">              pre.next = root.left;</span><br><span class="line">              pre = pre.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">              pre.next = root.right; </span><br><span class="line">              pre = pre.next;</span><br><span class="line">          &#125;</span><br><span class="line">          root = root.next; </span><br><span class="line">          <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123; <span class="comment">// reach the end of current layer</span></span><br><span class="line">              pre = dummyHead; <span class="comment">// shift pre back to the beginning, get ready to point to the first element in next layer  </span></span><br><span class="line">              root = dummyHead.next; ;<span class="comment">//root comes down one level below to the first available non null node</span></span><br><span class="line">              dummyHead.next = <span class="keyword">null</span>;<span class="comment">//reset dummyhead back to default null</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> real_root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 116. Populating Next Right Pointers in Each Node</title>
      <link href="/2021/08/08/LeetCode%20116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/"/>
      <url>/2021/08/08/LeetCode%20116.%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode.com/problems/populating-next-right-pointers-in-each-node/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="keyword">null</span>);        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node curr, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        curr.next = next;</span><br><span class="line">        dfs(curr.left, curr.right);</span><br><span class="line">        dfs(curr.right, curr.next == <span class="keyword">null</span> ? <span class="keyword">null</span> : curr.next.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 958. Check Completeness of a Binary Tree</title>
      <link href="/2021/08/07/LeetCode%20958.%20Check%20Completeness%20of%20a%20Binary%20Tree/"/>
      <url>/2021/08/07/LeetCode%20958.%20Check%20Completeness%20of%20a%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, determine if it is a <em>complete binary tree</em>.</p><p>In a <strong><a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">complete binary tree</a></strong>, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between <code>1</code> and <code>2h</code> nodes inclusive at the last level <code>h</code>.</p><p><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/">https://leetcode.com/problems/check-completeness-of-a-binary-tree/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> end = <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="keyword">null</span>) end = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(end) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 114. Flatten Binary Tree to Linked List</title>
      <link href="/2021/08/06/LeetCode%20114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/"/>
      <url>/2021/08/06/LeetCode%20114.%20Flatten%20Binary%20Tree%20to%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, flatten the tree into a “linked list”:</p><ul><li>The “linked list” should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li><li>The “linked list” should be in the same order as a <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR"><strong>pre-order</strong> <strong>traversal</strong></a> of the binary tree.</li></ul><p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        <span class="comment">// linked list only have 1 direction, the first node must be inserted as first</span></span><br><span class="line">        root.right = prev;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 572. Subtree of Another Tree</title>
      <link href="/2021/08/05/LeetCode%20572.%20Subtree%20of%20Another%20Tree/"/>
      <url>/2021/08/05/LeetCode%20572.%20Subtree%20of%20Another%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of<code> subRoot</code> and <code>false</code> otherwise.</p><p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node’s descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p><p><a href="https://leetcode.com/problems/subtree-of-another-tree/">https://leetcode.com/problems/subtree-of-another-tree/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isSame(s, t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t) || isSubtree(s.right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> &amp;&amp; t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(s.left, t.left) &amp;&amp; isSame(s.right, t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 543. Diameter of Binary Tree</title>
      <link href="/2021/08/04/LeetCode%20543.%20Diameter%20of%20Binary%20Tree/"/>
      <url>/2021/08/04/LeetCode%20543.%20Diameter%20of%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p><p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p><p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p><p><a href="https://leetcode.com/problems/diameter-of-binary-tree/">https://leetcode.com/problems/diameter-of-binary-tree/</a></p><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = maxDepth(root.right);</span><br><span class="line">        max = Math.max(max, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> recursive </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 226. Invert Binary Tree</title>
      <link href="/2021/08/03/LeetCode%20226.%20Invert%20Binary%20Tree/"/>
      <url>/2021/08/03/LeetCode%20226.%20Invert%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p><p><a href="https://leetcode.com/problems/invert-binary-tree/">https://leetcode.com/problems/invert-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct tree </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1676. Lowest Common Ancestor of a Binary Tree IV</title>
      <link href="/2021/08/02/LeetCode%201676.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20IV/"/>
      <url>/2021/08/02/LeetCode%201676.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20IV/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree and an array of <code>TreeNode</code> objects <code>nodes</code>, return <em>the lowest common ancestor (LCA) of <strong>all the nodes</strong> in</em> <code>nodes</code>. All the nodes will exist in the tree, and all values of the tree’s nodes are <strong>unique</strong>.</p><p>Extending the <strong><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a></strong>: “The lowest common ancestor of <code>n</code> nodes <code>p1</code>, <code>p2</code>, …, <code>pn</code> in a binary tree <code>T</code> is the lowest node that has every <code>pi</code> as a <strong>descendant</strong> (where we allow <strong>a node to be a descendant of itself</strong>) for every valid <code>i</code>“. A <strong>descendant</strong> of a node <code>x</code> is a node <code>y</code> that is on the path from node <code>x</code> to some leaf node.</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode[] nodes)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TreeNode t : nodes) set.add(t.val);</span><br><span class="line">        <span class="keyword">return</span> dfs(root, set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, Set&lt;Integer&gt; set)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(root.val)) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = dfs(root.left, set);</span><br><span class="line">        TreeNode right = dfs(root. right, set);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1644. Lowest Common Ancestor of a Binary Tree II</title>
      <link href="/2021/08/01/LeetCode%201644.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20II/"/>
      <url>/2021/08/01/LeetCode%201644.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor (LCA) of two given nodes,</em> <code>p</code> <em>and</em> <code>q</code>. If either node <code>p</code> or <code>q</code> <strong>does not exist</strong> in the tree, return <code>null</code>. All values of the nodes in the tree are <strong>unique</strong>.</p><p>According to the <strong><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a></strong>: “The lowest common ancestor of two nodes <code>p</code> and <code>q</code> in a binary tree <code>T</code> is the lowest node that has both <code>p</code> and <code>q</code> as <strong>descendants</strong> (where we allow <strong>a node to be a descendant of itself</strong>)”. A <strong>descendant</strong> of a node <code>x</code> is a node <code>y</code> that is on the path from node <code>x</code> to some leaf node.</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        TreeNode pNode = dfs(root, p.val), qNode = dfs(root, q.val);</span><br><span class="line">        <span class="keyword">return</span> (qNode == <span class="keyword">null</span> || pNode == <span class="keyword">null</span>) ? <span class="keyword">null</span> : lca(root, pNode, qNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode cur, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == target) <span class="keyword">return</span> cur;</span><br><span class="line">        TreeNode left = dfs(cur.left, target);</span><br><span class="line">        TreeNode right = dfs(cur.right, target);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lca</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lca(root.left, p, q);</span><br><span class="line">        TreeNode right = lca(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1650. Lowest Common Ancestor of a Binary Tree III</title>
      <link href="/2021/08/01/LeetCode%201650.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20III/"/>
      <url>/2021/08/01/LeetCode%201650.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree%20III/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two nodes of a binary tree <code>p</code> and <code>q</code>, return <em>their lowest common ancestor (LCA)</em>.</p><p>Each node will have a reference to its parent node. The definition for <code>Node</code> is below:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">    public int val;</span><br><span class="line">    public Node left;</span><br><span class="line">    public Node right;</span><br><span class="line">    public Node parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>According to the <strong><a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a></strong>: “The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    public Node lowestCommonAncestor(Node p, Node q) &#123;</span></span><br><span class="line"><span class="comment">        Set&lt;Node&gt; set = new HashSet&lt;&gt;();</span></span><br><span class="line"><span class="comment">        while(true)&#123;</span></span><br><span class="line"><span class="comment">            if (p != null &amp;&amp; !set.add(p)) return p;</span></span><br><span class="line"><span class="comment">            if (q != null &amp;&amp; !set.add(q)) return q;</span></span><br><span class="line"><span class="comment">            if (p != null) p = p.parent;</span></span><br><span class="line"><span class="comment">            if (q != null) q = q.parent;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Time complexity: O(n)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Space complexity: O(n)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span></span>&#123;</span><br><span class="line">        Node a = p, b = q;</span><br><span class="line">        <span class="keyword">while</span> (a != b)&#123;</span><br><span class="line">            a = a == <span class="keyword">null</span> ? q : a.parent;</span><br><span class="line">            b = b == <span class="keyword">null</span> ? p : b.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(1)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2021/07/26/LeetCode%20236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/"/>
      <url>/2021/07/26/LeetCode%20236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) <span class="keyword">return</span> l == <span class="keyword">null</span> ? r : l;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/2021/07/25/LeetCode%20235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/"/>
      <url>/2021/07/25/LeetCode%20235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1382. Balance a Binary Search Tree</title>
      <link href="/2021/07/24/LeetCode%201382.%20Balance%20a%20Binary%20Search%20Tree/"/>
      <url>/2021/07/24/LeetCode%201382.%20Balance%20a%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p><p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p><p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/">https://leetcode.com/problems/balance-a-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">balanceBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> bulid(<span class="number">0</span>, res.size() - <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        dfs(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">bulid</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/ <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(res.get(mid));</span><br><span class="line">        root.left = bulid(left, mid - <span class="number">1</span>, res);</span><br><span class="line">        root.right = bulid(mid + <span class="number">1</span>, right, res);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2021/07/23/LeetCode%20108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/"/>
      <url>/2021/07/23/LeetCode%20108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/ <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(logn)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 173. Binary Search Tree Iterator</title>
      <link href="/2021/07/22/LeetCode%20173.%20Binary%20Search%20Tree%20Iterator/"/>
      <url>/2021/07/22/LeetCode%20173.%20Binary%20Search%20Tree%20Iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)">in-order traversal</a></strong> of a binary search tree (BST):</p><ul><li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li><li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li><li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li></ul><p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p><p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">https://leetcode.com/problems/binary-search-tree-iterator/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        pushAllLeft(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        pushAllLeft(node.right);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAllLeft</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(h)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 199. Binary Tree Right Side View</title>
      <link href="/2021/07/21/LeetCode%20199.%20Binary%20Tree%20Right%20Side%20View/"/>
      <url>/2021/07/21/LeetCode%20199.%20Binary%20Tree%20Right%20Side%20View/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><a href="https://leetcode.com/problems/binary-tree-right-side-view">https://leetcode.com/problems/binary-tree-right-side-view</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            res.add(q.peek().val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 110. Balanced Binary Tree</title>
      <link href="/2021/07/20/LeetCode%20110.%20Balanced%20Binary%20Tree/"/>
      <url>/2021/07/20/LeetCode%20110.%20Balanced%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p></blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/">https://leetcode.com/problems/balanced-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lh = getHeight(node.left), rh = getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span> (lh == -<span class="number">1</span> || rh == -<span class="number">1</span> || Math.abs(lh - rh) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(lh, rh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 129. Sum Root to Leaf Numbers</title>
      <link href="/2021/07/19/LeetCode%20129.%20Sum%20Root%20to%20Leaf%20Numbers/"/>
      <url>/2021/07/19/LeetCode%20129.%20Sum%20Root%20to%20Leaf%20Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><ul><li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li></ul><p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>leaf</strong> node is a node with no children.</p><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, top down</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        num = num * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) dfs(root.left, num);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) dfs(root.right, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top down general steps:</span><br><span class="line">1. base case(leaf)</span><br><span class="line">2. 利用父问题传下来的值做计算 num = 10*num + num</span><br><span class="line">3. 额外操作</span><br><span class="line">4. 把值传给子问题递归 dfs()</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS(tree) </tag>
            
            <tag> top down </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 124. Binary Tree Maximum Path Sum</title>
      <link href="/2021/07/18/LeetCode%20124.%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
      <url>/2021/07/18/LeetCode%20124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxvalue = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxvalue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(node.right);</span><br><span class="line">        left = left &lt; <span class="number">0</span> ? <span class="number">0</span> : left;</span><br><span class="line">        right = right &lt; <span class="number">0</span> ? <span class="number">0</span> : right;</span><br><span class="line">        maxvalue = Math.max(maxvalue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bottom up general steps:</span><br><span class="line">1. Base case</span><br><span class="line">2. 向子问题要答案</span><br><span class="line">3. 利用子问题构建当前答案</span><br><span class="line">4. 额外操作</span><br><span class="line">5. 返回答案给父问题</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 104. Maximum Depth of Binary Tree</title>
      <link href="/2021/07/17/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree/"/>
      <url>/2021/07/17/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bottom up general steps:</span><br><span class="line">1. Base case</span><br><span class="line">2. 向子问题要答案</span><br><span class="line">3. 利用子问题构建当前答案</span><br><span class="line">4. 额外操作</span><br><span class="line">5. 返回答案给父问题</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 98. Validate Binary Search Tree</title>
      <link href="/2021/07/16/LeetCode%2098.%20Validate%20Binary%20Search%20Tree/"/>
      <url>/2021/07/16/LeetCode%2098.%20Validate%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol><li><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul></li></ol><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> minVal, <span class="keyword">long</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= maxVal || root.val &lt;= minVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 450. Delete Node in a BST</title>
      <link href="/2021/07/15/LeetCode%20450.%20Delete%20Node%20in%20a%20BST/"/>
      <url>/2021/07/15/LeetCode%20450.%20Delete%20Node%20in%20a%20BST/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">https://leetcode.com/problems/delete-node-in-a-bst/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; root.val) root.left = deleteNode(root.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root.val) root.right = deleteNode(root.right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root.val = findMin(root.right);</span><br><span class="line">            root.right = deleteNode(root.right, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(logn)</p><p>Space complexity: O(H)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> delete node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
      <link href="/2021/07/14/LeetCode%20426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/"/>
      <url>/2021/07/14/LeetCode%20426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Convert a <strong>Binary Search Tree</strong> to a sorted <strong>Circular Doubly-Linked List</strong> in place.</p><p>You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p><p>We want to do the transformation <strong>in place</strong>. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p><p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,5,1,3]</span><br><span class="line">Output: [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [1,2,3]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        inorderTraversal(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root.left); <span class="comment">//left</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) head = root;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.right = root; <span class="comment">//root</span></span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorderTraversal(root.right); <span class="comment">//right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> Convert tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2021/07/13/LeetCode%20106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/"/>
      <url>/2021/07/13/LeetCode%20106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [-1], postorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – postorder traversal, inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">        N = inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) inMap.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">        <span class="keyword">int</span> inIndex = inMap.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> rightTreeSize = inEnd - inIndex;</span><br><span class="line">        root.left = helper(inStart, inIndex - <span class="number">1</span>, postStart, postEnd - rightTreeSize -<span class="number">1</span>);</span><br><span class="line">        root.right = helper(inIndex + <span class="number">1</span>, inEnd, postEnd - rightTreeSize, postEnd -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2021/07/12/LeetCode%20105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/"/>
      <url>/2021/07/12/LeetCode%20105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal, inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="keyword">int</span> preOrderIndex;</span><br><span class="line">    Map&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.preOrderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = preorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) treeMap.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> helperbulid(<span class="number">0</span>, N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helperbulid</span><span class="params">(<span class="keyword">int</span> instart, <span class="keyword">int</span> inend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preOrderIndex++]);</span><br><span class="line">        <span class="keyword">int</span> index = treeMap.get(root.val);</span><br><span class="line">        root.left = helperbulid(instart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helperbulid(index + <span class="number">1</span>, inend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1008. Construct Binary Search Tree from Preorder Traversal</title>
      <link href="/2021/07/11/LeetCode%201008.%20Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/"/>
      <url>/2021/07/11/LeetCode%201008.%20Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p><p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p><p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p><p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [1,3]</span><br><span class="line">Output: [1,null,3]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, N;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == N) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = preorder[index];</span><br><span class="line">        <span class="keyword">if</span> (val &lt; lower || val &gt; upper) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        index ++;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = helper(lower, val);</span><br><span class="line">        root.right = helper(val, upper);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        N = preorder.length;</span><br><span class="line">        <span class="keyword">return</span> helper(Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 449. Serialize and Deserialize BST</title>
      <link href="/2021/07/10/LeetCode%20449.%20Serialize%20and%20Deserialize%20BST/"/>
      <url>/2021/07/10/LeetCode%20449.%20Serialize%20and%20Deserialize%20BST/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p><p><strong>The encoded string should be as compact as possible.</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String res = String.valueOf(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) res += <span class="string">&quot;,&quot;</span> + serialize(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) res += <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(Queue&lt;String&gt; q, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String s = q.peek();</span><br><span class="line">        <span class="keyword">int</span> val = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; lower || val &gt; upper) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        q.poll();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = deserialize(q, lower, val);</span><br><span class="line">        root.right = deserialize(q, val, upper);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Serialize and Deserialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 297. Serialize and Deserialize Binary Tree</title>
      <link href="/2021/07/09/LeetCode%20297.%20Serialize%20and%20Deserialize%20Binary%20Tree/"/>
      <url>/2021/07/09/LeetCode%20297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + serialize(root.left) + <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> helper(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">        String s = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;#&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(s));</span><br><span class="line">        root.left = helper(q);</span><br><span class="line">        root.right = helper(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Serialize and Deserialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2021/07/08/LeetCode%20103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/"/>
      <url>/2021/07/08/LeetCode%20103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) level.add(cur.val);</span><br><span class="line">                <span class="keyword">else</span> level.add(<span class="number">0</span>, cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 107. Binary Tree Level Order Traversal II</title>
      <link href="/2021/07/07/LeetCode%20107.%20Binary%20Tree%20Level%20Order%20Traversal%20II/"/>
      <url>/2021/07/07/LeetCode%20107.%20Binary%20Tree%20Level%20Order%20Traversal%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 102. Binary Tree Level Order Traversal</title>
      <link href="/2021/07/06/LeetCode%20102.%20Binary%20Tree%20Level%20Order%20Traversal/"/>
      <url>/2021/07/06/LeetCode%20102.%20Binary%20Tree%20Level%20Order%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 145. Binary Tree Postorder Traversal</title>
      <link href="/2021/07/04/LeetCode%20145.%20Binary%20Tree%20Postorder%20Traversal/"/>
      <url>/2021/07/04/LeetCode%20145.%20Binary%20Tree%20Postorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(<span class="number">0</span>, root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 94. Binary Tree Inorder Traversal</title>
      <link href="/2021/07/03/LeetCode%2094.%20Binary%20Tree%20Inorder%20Traversal/"/>
      <url>/2021/07/03/LeetCode%2094.%20Binary%20Tree%20Inorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 144. Binary Tree Preorder Traversal</title>
      <link href="/2021/07/02/LeetCode%20144.%20Binary%20Tree%20Preorder%20Traversal/"/>
      <url>/2021/07/02/LeetCode%20144.%20Binary%20Tree%20Preorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论兴趣</title>
      <link href="/2021/01/01/%E8%AE%BA%E5%85%B4%E8%B6%A3/"/>
      <url>/2021/01/01/%E8%AE%BA%E5%85%B4%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>写下这篇文章是想说说我对专业与兴趣之间的关系的看法。当我们大学选专业的时候，当我们研究生选方向的时候，当我们博士选方向的时候，当我们工作选岗位的时候，都会很疑惑到底哪个方向更适合自己。询问了一堆前辈后，有的告诉你要根据前景选，有的告诉你要根据兴趣选，最后困扰我们的问题就变成了，到底是选一个自己感兴趣的方向还是选一个前景好的方向？这个问题就是本文主要想讨论的一个问题。</p><p>面对一个问题，我们先要来深入了解一下，这个问题的本质是什么。所以，我想先说说我对兴趣的看法。我对兴趣的看法始终都是：<strong>不要把兴趣看得多么崇高，你做的好你就感兴趣，你做的不好你就不感兴趣。</strong></p><span id="more"></span><p>拿大学选专业做个例子，很大一部分人会选择化学类的专业的原因就是因为他们高中化学学的非常好，有的化学不怎么学就一直考满分，有的参加过各种竞赛拿到了金奖。这种经历给他们一种感觉，我化学学的非常好所以我对化学是有天分的。同时，因为他们的化学成绩好，周围的同学和老师时不时的称赞更增强了这种感觉。</p><p>于是，这群人就选了化学作为大学专业，可是等到了大学，其中的一部分人却发现化学学起来没那么简单了，慢慢的他们再也找不到当初高中时周围人一直称赞的感觉，每门科目都学的很吃力，这时候你猜他们对化学还感兴趣吗？</p><p>还有一部分人，大学化学依然学的很好，这群人依然活在他人的称赞中，在完成了基本的课业后，还有余力去实验室做做实验，可是等这群人去了实验室之后发现，做实验没有自己想的那么有趣。大部分的实验都是机械的重复，再强的通风橱也不能完全挡住化学药品的味道，每天机械的重复过柱子，收集产物，有些动手能力稍微差点的人还会时不时打碎些仪器，在师兄师姐的注视中窘迫的打扫着碎掉的仪器，这时候你猜他们对化学还感兴趣吗？</p><p>还有一部分人，大学成绩还可以，做实验也不错，跟着师兄师姐们混到了文章或者自己发出来文章，又受到了周围人的称赞，于是这部分人认为自己对于化学真的有天分，继续往下读研、读博。刚到了新环境，一开始这部分人发现做实验很简单，随便做做电极材料，组组电池，测测性能，一套表征，一篇文章就出来了。于是，换种材料，继续相同的操作，相同的实验操作，然后再换材料，不断的重复，这个时候他们感觉自己每天像个机器一样，重复做着没啥用的东西，目的只是为了发出一些很难创造生产力的paper。然后，你似乎无意间发现你以前的同学已经在某歌，某书，某鹅，某字公司拿了几十万的package，你也开始考虑自己以后的工作，看着各种高校青椒的招聘要求和一言难尽的工资，以及各种论坛青椒们吐槽的压力，再看看不断上涨的房价，用这些工资在稍微好一点的城市买个厕所都难，这时候你猜他们对化学还感兴趣吗？</p><p>当然，还有一部分人，他们做的研究是开创性的，是具有划时代意义的，是真正沉下心来搞研究的，他们慢慢的做着研究，享受着研究。半夜想到了新的点子，会忍不住爬起来，跑去实验室尝试自己的新想法。毫无疑问，这部分人才是真正的热爱化学。可是，能做到这样的人，又有多少呢？</p><p>所以，我一直觉得，<strong>兴趣就是你做的好你就有兴趣，没什么神秘的。</strong></p><p>当明确了兴趣对于大多数人来说意味着什么，我们的问题就可以进入下一阶段了。做的好就有兴趣这种特征，给了兴趣很大的可塑造性。我们的幸福感是由一个又一个的正反馈组成。你可以选择一个有前景的方向，并把那个方向培养成你兴趣，当你选择一个有前景的方向时，你会发现你能更加容易的获得这一个又一个的正反馈，最终可以更容易实现快乐生活，快乐工作。</p><p>那么，如何选择一个有前景的方向的就变成了一个新的问题。这个问题有一个通用解，不过通用解也有些弊端，相关细节某乎上一搜一大堆，在这里不做过多的阐述，我们来聊些别的。</p><p>马克思说：“<strong>人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和</strong>”。人是一种社会性的生物，仅靠自己很难生活下去，我们必定要和这个社会产生联系。一个社会的发展会有他的大趋势，如果我们可以让我们的方向趋于社会发展的方向，那样做起事才会事半功倍。这也就是人们常说的，坐在风口上猪都能飞起来。那种两耳不闻窗外事，一心只读圣贤书的生活已经极度不适合当下的社会。</p><p>拿一艘在奔流的河道中前行的船举个例子，河流的方向就是社会发展的方向，我们就是这一艘艘船，我们的能力就是船的动力，努力就是向船中加入更大的燃料，获得更大的动力，选择就是掌舵，控制船前行的方向。当我们控制船前行的方向和河流的方向一致时，你会发现你不怎么用力就可以前行的很快，当我们前行的方向不一致时，我们需要更多的努力才能和上一种情况的船具备相同的速度。选择和努力的区别，个人方向和社会方向的统一性与差异性就在这里。</p><p>接下来，我想来谈一个和我们常识有些不一样的问题。那就是，我们一直选择我们认为的最优的方案，最后的结果是不是最优？这个问题也可以抽象成一个数学问题，<strong>贪心算法能不能得到全局最优解？</strong>和大部分人认知不一样的是，如果我们每一步都是最优解，这个结果会将我们导向一个局部最优解，我们大多数的时候是得不到全局最优解的。就像下图所示一样。</p><img src="https://raw.githubusercontent.com/MrainW/Markdown-Photos/master/Photos/Picture1.png" alt="Picture1" style="zoom:50%;" /><p>如果我们经常交流的是和自己所处环境类似的人，或者向他们请教经验，这些经验只是会加快我们走向局部最优解的速度，并不能帮助我们导向其他更好的解。因为我们的处在相似的环境，在类似的环境下，我们的想法也趋于一致。</p><p>比如说，某合成实验室的新生张三，某一天向他的师兄请教哪个方向适合作为博士的开题方向，张三的师兄耐心的给他分析了，方案一只是机械的在本体上接了一个甲基，创新性不够，方案二虽然只是多合成了几个碳链，但是却可以在溶剂里自组装成胶束，方案二更新颖一点。当张三回到家里和他隔壁实验室的舍友交流时，他的舍友告诉他，你们老板不是还有一个电催化的大课题，你去做那个方向啊，电催化实验周期短，不用苦逼的合成过柱子，你发一篇合成的文章的功夫都够发两篇电催化的文章了。或许，当张三和他的金融系同学，医学院同学和计算机学院的同学交流时又会得到不同的回答。</p><p>当我们交流的对象都是和我们处于同一环境的人的时候，我们很难跳出这个局部最优解。你认为的所采取的解决方案，反而很大可能加快了你走向局部最优解的过程。同时，走向这个局部最优解的过程，你得到的正反馈是会越来越多的，你是会有你变得越来越幸福的感觉。只有当某一天，你真正的遇到了在这个局部最优解无所解决的问题，你才会意识到自己到了这个局部最优解。我们的想法和思维方式大多都来源于后天的学习，环境对我们的影响非常大，一直处于一种类型的环境会极大的限制住我们的思维，最终将你自己关在监狱里的正是你自己。</p><p>突破这种思维的僵局的一种非常有效的方式就是开源。你要多和不同领域的人交流，了解不同领域的知识，这些会帮助你确定一个导向更优的解的方向。然后你再努力，努力是加速你到达你确定的那个最优解的基本要求，选择则是帮助你确定一个比较好的解。</p><p>其实这些对于很多人都明白，只是人很喜欢待在自己所处的舒适区，不愿意改变。就像<strong>电磁感应现象</strong>一样，总是阻碍着变化。人又和一些基本的物理定律统一了，这或许也是我们来源世界，没有啥特殊性的一种表现。</p><p>这篇文章只是我在现阶段的一些感想，本来也只是提供一种思维的方式，人总是会变的，就像《平凡的世界》里的张有智和周文龙，一个由好变坏，一个由坏变好，我们终究是需要用变化的眼光看待所有的事。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园三</title>
      <link href="/2020/08/20/%E5%A4%A7%E8%A7%82%E5%9B%AD3/"/>
      <url>/2020/08/20/%E5%A4%A7%E8%A7%82%E5%9B%AD3/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>五年前。</p><p>小楼无聊的在床上刷着手机，不时发出阵阵笑声。</p><p>“大威天龙，世尊地藏，般若诸佛，般若巴嘛空。“</p><p>“三年之期已到！恭迎龙王√“</p><p>“生不出人，我很抱歉“</p><p>“人在美国，刚下飞机”</p><p>“。。。。。。”</p><p>“嗡嗡嗡”</p><span id="more"></span> <p>忽然一封邮件打破了他的欢乐，他迟疑了一会，慢慢的拿起来旁边的手机，心剧烈的跳动着，然后他深吸了口气，打开了屏保，狠下心来，点开了那封邮件——原来只是个广告。</p><p>虚惊一场！</p><p>没等他放下手机，又一封邮件发过来了，他顺手打开了那封邮件，短暂的沉默后，他嘴角露出了一丝微笑。小楼终于收到了他梦寐以求的公司的offer。他曾经幻想着，当自己成功进入那家公司后，自己会多么激动，可真正发生后，有的只是平静。</p><p>很多人都喜欢小狗，但是有些人本身却对小狗过敏，不能接触小狗，机器狗的出现就完美的解决了这个问题。在当今的时代，人们已经可以制造出，和真实的狗非常相似的机器狗了。</p><p>这种机器狗不只智力和外表与普通的狗相同，更惊人的是他们不会衰老，可以陪伴你一生。但是机器狗也会损坏，正常的狗生病会去宠物医院，他们损坏时就要去专门的机器狗宠物医院去维修。</p><p>小楼的工作就是维修坏掉的机器狗。</p><p>第一次见到机器狗，小楼很吃惊，他们摸上去和正常的狗完全一样，还不会掉毛。甚至连摸他的反应也和正常的狗一样。小楼根本分不出哪些是正常的狗，哪些是机器狗。</p><p>小楼维修的第一只宠物狗是一位老奶奶的，宠物狗的名字叫家宝，和老奶奶的孩子同名。老奶奶自己一个人住在家里，她的老伴和孩子在多年前的一场席卷全球的冠状病毒中去世了，这么多年来就只有家宝陪伴着她了。他会陪着老奶奶看电视，陪着老奶奶散步，陪着老奶奶去超市，家宝就是老奶奶所有的精神支柱了。</p><p>小楼永远都忘不了，老奶奶抱着碎裂的家宝躯体来宠物医院的那一天，老奶奶用颤抖的声音求着小楼一定要治好家宝，小楼望着老奶奶湿润的双眼，郑重的承诺一定会治好家宝。</p><p>望着已经碎成好几段的家宝，小楼从心脏的位置取出了家宝的芯片，这个芯片就是家宝与老奶奶所有的记忆。这些记忆其实就是一个又一个的程序，家宝和老奶奶的每一次交流都会改变程序的参数或者产生新的程序，这些程序就全部储存在芯片中，组成了家宝的记忆。</p><p>小楼看着已经裂开的芯片，从仓库中取出一个新的芯片，将旧芯片的数据全部拷贝到新芯片中，</p><p>然后将芯片插入到另一只和家宝型号一样的机器狗体内，那样这个新的机器狗就继承了家宝全部的记忆，并拥有和家宝一样的外貌。</p><p>小楼刚启动了新家宝，家宝就迅速跑出去，一溜烟的扑向了老奶奶的怀里，老奶奶紧紧抱着怀里的家宝，激动的热泪盈眶。</p><p>望着老奶奶怀里的家宝，小楼不禁产生了一个疑问，他和碎成渣的旧家宝到底哪个是家宝，新家宝身上没有一个零件是来自旧家宝，甚至连承载记忆的芯片都是新的，只有拷贝过来的记忆是旧家宝的。</p><p>看着老奶奶激动的样子，小楼终究还是没有把心里的想法告诉老奶奶。</p><p>回到修理室，小楼默默的把残缺家宝的遗体，带去医院后山埋了起来，感谢旧家宝陪伴了老奶奶这么久，就让这只忒修斯之狗长眠于此把。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园二</title>
      <link href="/2020/05/18/%E5%A4%A7%E8%A7%82%E5%9B%AD2/"/>
      <url>/2020/05/18/%E5%A4%A7%E8%A7%82%E5%9B%AD2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>轰隆隆, 飞机终于起飞了。下面的房屋越来越远，渐渐消失在视野中。</p><p>大痣一上飞机就闭上了眼睛，身体似乎还有些发抖。小楼在旁边看着大痣，嘴角露出了一丝坏笑。大痣虽然什么都看得都比小楼透彻，但就是害怕坐飞机。偏偏大痣每次都嘴硬的说自己完全不怕，只是感觉飞机的冷气开的太足了，自己是被冻的发抖。每每看到大痣这个样子，小楼总会很开心，虽然他什么都不如大痣，但至少在这一点他觉得自己终于胜过大痣了。</p> <span id="more"></span><p>不再去管大痣，小楼打望着周围。</p><p>座位前方是一位带着孩子的年轻妈妈，小孩子奶声奶气的想让妈妈给她讲故事；不远处是一位面色蜡黄的老爷爷，老爷爷似乎是得了什么病，不时发出一阵阵压抑着的呻吟；后面是一对恩爱的情侣，那位男生不知道说了什么，惹得女生娇羞的用手轻打着男生，男生则满脸洋溢着宠溺的笑。</p><p>小楼很喜欢静静的看着周围发生的这些，他感到这些充满着生活的气息，喜怒哀乐在同一场景呈现着，每个人都有自己独特的地方，这些画面会让他感到很平和。</p><p>深吸一口气，他感到生活充满着希望。</p><p>收回目光，小楼拿出了一副耳塞一样的东西，通体呈银色，两边有些斑驳的黄点，顶端有一行蓝色的小字，细细看去正是大观园这三个字。看到这三个字的时候，小楼忍不住吐槽，这家公司有点意思啊，这是在嘲笑我们都是刘姥姥吗？</p><p>说起这大观园，这是一家很奇幻的科技公司，据说这是全球所有国家共同建立起的一家公司，这家公司成立的目的只有一个——探寻人类最终的归宿。每个国家将自己收集来的全部历史数据无偿的提供给这家公司，这家公司便利用了这些数据，建立了很多模拟的世界，从宇宙大爆炸开始，以远超于现实世界的速度进化着，想借此探寻人类最终的归宿在哪里，人类存在的意义是什么。</p><p>而大观园则是这家公司众多模拟世界里最成功的一个。最惊奇的是，通过那银色的耳塞，你甚至可以把自己的意识上传到大观园，以观察者的身份暂居在大观园内的虚拟生命体上。</p><p>“嗖啦”</p><p>小楼带上了耳塞，缓缓闭上了眼睛，进入了大观园。</p><p>再睁开眼，小楼发现自己来到了一间石头堆砌的小房子，很简陋，墙上挂满着各种石磨的武器，还有很多动物皮一样的东西。房子中央是一个木头搭起来的小桌子，桌子上还有石制的容器，里面装满着水。在一个角落里，是一个堆砌的石堆，里面竟然是燃烧后的木头。小楼感到一切惊奇，大观园才刚演化100年，竟然已经发展到可以生火，造房屋了，真是神奇。</p><p>再看向自己寄居的模拟体，是一个狮子摸样的模拟体，正在休息。狮子的尾巴已经消失不见了，前脚演化成像人类手掌一样，手心还有厚厚的肉垫，肚子鼓鼓的，显得胖嘟嘟的。身上依然是毛绒绒的，可可爱爱。</p><p>小楼心想：原来这个模拟世界的“人类”竟然是狮子演变来的吗。</p><p>小楼想用手去摸摸他手掌的肉球，可是发现自己什么也做不了。</p><p>这是大观园公司做的限制，为了不让外来的观察者改变这里的演化，所有进来的人，都只能是观察者。小楼感觉到有些失望，自己好不容易才得到的大观园测观察者的资格竟然只能做到这些。</p><p>忽然，小楼寄居的狮子要醒过来了。小楼正处于刚才失望的心情中，就想捉弄一下他。就用意念强制不让狮子醒过来，他可以感受到狮子的意识是清醒的，但是却失去了对身体的控制权。只能躺在石头床上，一动不动。感受到狮子惊恐的意识，小楼内心有种诡计得逞的窃喜。</p><p>渐渐的，狮子意识越来越清醒，小楼越来越压抑不住狮子的行为。一个不留神，身体的控制权就被狮子夺回去了。</p><p>狮子猛的从石床上跳起来，大口的喘着粗气。眼中充满恐惧，一阵后怕。</p><p>狮子想起，在自己小的时候曾听自己的妈妈讲过她之前也有过类似的经历，意识清醒却怎么也醒不过来，就像被鬼压在身上一样。当时他还以为自己的妈妈只是为了吓唬他，可以让他多出去狩猎锻炼一下，不要老待在石屋里睡觉，没想到今天自己竟然真的遇到了。</p><p>他还记得他的妈妈把这种经历叫做——鬼压床。</p><p>感受到狮子刚才的想法，小楼内心涌出一股寒意，他想起自己曾经也有过好多次鬼压床的经历。但随即他又摇摇头，压下自己突然出现的不切实际的想法。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园一</title>
      <link href="/2020/05/04/%E5%A4%A7%E8%A7%82%E5%9B%AD1/"/>
      <url>/2020/05/04/%E5%A4%A7%E8%A7%82%E5%9B%AD1/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>“大痣，大痣，愣在那干什么呢，快走了，要赶不上回家的飞机了！”</p><p>恍惚中被惊醒的的大痣，快步追了上去。其实大痣本名并不叫大痣，他名叫吴用。只是大痣眼角有一颗痣，大家便大痣大痣的叫了下来。</p><p>说起这大痣，他小时候却有另一个外号，没错，就是智多星吴用。那时的他勤奋好奇，博古通今，倒也真对得住这称呼。在他小学时，有次年级大会，有位学校重金聘请过来的国学大师，在台上“指点江山，激扬文字”，他实在听不下去了，直接走上台去，在全年级的同学的一阵惊呼中，指出了他刚才讲的19个错误。全场一片哗然，然后他就像个没事人似的默默的走下了台，只留下身后阵阵的掌声。虽然那件事后，他就被叫去谈话了，但大家都知道他不会变的，吴用就是吴用，要是这么通人情，懂变通，也不会只有小楼一个朋友了。</p><span id="more"></span><p>小楼是大痣唯一的一个朋友，他们从小学就是朋友了，一直到后来工作，他们也都是朋友，他见证着大痣从天才到“平庸”的变化。小楼和大痣不同，他是典型的乖学生，从不迟到早退，从不顶撞老师，在家听父母的话，在外尊敬师长。为数不多的几次“造反”经历，全是被大痣蛊惑的。大痣总调侃他，生活过的像你这样规规矩矩，一眼就忘得见未来，还有什么意思。学习时只知道学习，工作后只为了赚钱，你的人生到底是为什么活着的？小楼则总是不甘示弱的回复到，要是像你一样活着，我出门早就被人乱棍打死了，现在坟头草都一丈多了，你放心你死后不会寂寞的，我会每天都去你坟头蹦迪的。</p><p>不过在夜深人静的时候，小楼也总会去想大痣的话。他越来越感觉到自己的生活过的很平淡，他不知道自己到底是为了什么活下去的。他想起，自己小时候班里的老师问学生，你们以后的梦想是什么？有的回答周游世界，有的回答想当老师，有的想当超人，他记得自己当时回答说想当科学家，去探索世界的奥秘。可是他知道，那只是因为自己害怕其他人都有梦想，自己啥都没有而胡乱编出来的。他不像大痣，能把一切都看的很透彻，他只是个普通人。</p><p>有次大痣问小楼，你听过那个细铁链拴大象的故事吗？小楼说，我听过啊，不就是一只大象从小就被细铁链栓住，虽然现在它已经有足够的力气挣脱它了，但是无形的锁链依然禁锢着它。那你觉得你和这个大象有什么区别？小楼突然感觉心里一颤，他感到自己内心最柔软的地方突然被刺了一下。大痣继续说，我告诉你，没有区别，相反我觉得你比那大象更可怜。虽然你看不到，但你身上无形的铁链，已经把你紧紧的束缚住了。每个人从一开始，都是一张白纸，从一出生后，我们就开始被无形的铁链缠绕的一生了。这些铁链你看不到，但却限制着你的行为，像把你关进了监狱，一座你永远也逃不出的监狱。你想要的，你所认为自由的思想，你所谓的价值观，你所追求的理想的生活，全都是别人告诉你的，其实你只是一张被社会用过的打草纸罢了。</p><p>小楼感到自己被一种不知名的情绪包裹着，他看着大痣，缓缓的低下了头。</p><p>再回过神，大痣已经走远了，只留下一句随风飘来的话，小楼别怪我，一句话语只有刺痛你内心最软弱的地方才会改变你，我不想你浑浑噩噩的活下去。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
