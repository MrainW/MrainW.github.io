<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode 236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2021/07/26/LeetCode%20236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/"/>
      <url>/2021/07/26/LeetCode%20236.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode l = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode r = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span> || r == <span class="keyword">null</span>) <span class="keyword">return</span> l == <span class="keyword">null</span> ? r : l;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/2021/07/25/LeetCode%20235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/"/>
      <url>/2021/07/25/LeetCode%20235.%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p><p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1382. Balance a Binary Search Tree</title>
      <link href="/2021/07/24/LeetCode%201382.%20Balance%20a%20Binary%20Search%20Tree/"/>
      <url>/2021/07/24/LeetCode%201382.%20Balance%20a%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary search tree, return <em>a <strong>balanced</strong> binary search tree with the same node values</em>. If there is more than one answer, return <strong>any of them</strong>.</p><p>A binary search tree is <strong>balanced</strong> if the depth of the two subtrees of every node never differs by more than <code>1</code>.</p><p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/">https://leetcode.com/problems/balance-a-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">balanceBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, res);</span><br><span class="line">        <span class="keyword">return</span> bulid(<span class="number">0</span>, res.size() - <span class="number">1</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        dfs(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">bulid</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, List&lt;Integer&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left)/ <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(res.get(mid));</span><br><span class="line">        root.left = bulid(left, mid - <span class="number">1</span>, res);</span><br><span class="line">        root.right = bulid(mid + <span class="number">1</span>, right, res);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 108. Convert Sorted Array to Binary Search Tree</title>
      <link href="/2021/07/23/LeetCode%20108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/"/>
      <url>/2021/07/23/LeetCode%20108.%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an integer array <code>nums</code> where the elements are sorted in <strong>ascending order</strong>, convert <em>it to a <strong>height-balanced</strong> binary search tree</em>.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start)/ <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = helper(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(logn)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 173. Binary Search Tree Iterator</title>
      <link href="/2021/07/22/LeetCode%20173.%20Binary%20Search%20Tree%20Iterator/"/>
      <url>/2021/07/22/LeetCode%20173.%20Binary%20Search%20Tree%20Iterator/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)">in-order traversal</a></strong> of a binary search tree (BST):</p><ul><li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li><li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li><li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li></ul><p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p><p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p><p><a href="https://leetcode.com/problems/binary-search-tree-iterator/">https://leetcode.com/problems/binary-search-tree-iterator/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        pushAllLeft(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        pushAllLeft(node.right);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAllLeft</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(h)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> iterator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 199. Binary Tree Right Side View</title>
      <link href="/2021/07/21/LeetCode%20199.%20Binary%20Tree%20Right%20Side%20View/"/>
      <url>/2021/07/21/LeetCode%20199.%20Binary%20Tree%20Right%20Side%20View/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p><p><a href="https://leetcode.com/problems/binary-tree-right-side-view">https://leetcode.com/problems/binary-tree-right-side-view</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            res.add(q.peek().val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 110. Balanced Binary Tree</title>
      <link href="/2021/07/20/LeetCode%20110.%20Balanced%20Binary%20Tree/"/>
      <url>/2021/07/20/LeetCode%20110.%20Balanced%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the left and right subtrees of <em>every</em> node differ in height by no more than 1.</p></blockquote><p><a href="https://leetcode.com/problems/balanced-binary-tree/">https://leetcode.com/problems/balanced-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lh = getHeight(node.left), rh = getHeight(node.right);</span><br><span class="line">        <span class="keyword">if</span> (lh == -<span class="number">1</span> || rh == -<span class="number">1</span> || Math.abs(lh - rh) &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(lh, rh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 129. Sum Root to Leaf Numbers</title>
      <link href="/2021/07/19/LeetCode%20129.%20Sum%20Root%20to%20Leaf%20Numbers/"/>
      <url>/2021/07/19/LeetCode%20129.%20Sum%20Root%20to%20Leaf%20Numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><ul><li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li></ul><p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>leaf</strong> node is a node with no children.</p><p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">https://leetcode.com/problems/sum-root-to-leaf-numbers/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, top down</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        num = num * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) dfs(root.left, num);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) dfs(root.right, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top down general steps:</span><br><span class="line">1. base case(leaf)</span><br><span class="line">2. 利用父问题传下来的值做计算 num = 10*num + num</span><br><span class="line">3. 额外操作</span><br><span class="line">4. 把值传给子问题递归 dfs()</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(h)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS(tree) </tag>
            
            <tag> top down </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 124. Binary Tree Maximum Path Sum</title>
      <link href="/2021/07/18/LeetCode%20124.%20Binary%20Tree%20Maximum%20Path%20Sum/"/>
      <url>/2021/07/18/LeetCode%20124.%20Binary%20Tree%20Maximum%20Path%20Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">https://leetcode.com/problems/binary-tree-maximum-path-sum/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxvalue = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> maxvalue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(node.right);</span><br><span class="line">        left = left &lt; <span class="number">0</span> ? <span class="number">0</span> : left;</span><br><span class="line">        right = right &lt; <span class="number">0</span> ? <span class="number">0</span> : right;</span><br><span class="line">        maxvalue = Math.max(maxvalue, left + right + node.val);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bottom up general steps:</span><br><span class="line">1. Base case</span><br><span class="line">2. 向子问题要答案</span><br><span class="line">3. 利用子问题构建当前答案</span><br><span class="line">4. 额外操作</span><br><span class="line">5. 返回答案给父问题</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 104. Maximum Depth of Binary Tree</title>
      <link href="/2021/07/17/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree/"/>
      <url>/2021/07/17/LeetCode%20104.%20Maximum%20Depth%20of%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left),maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bottom up general steps:</span><br><span class="line">1. Base case</span><br><span class="line">2. 向子问题要答案</span><br><span class="line">3. 利用子问题构建当前答案</span><br><span class="line">4. 额外操作</span><br><span class="line">5. 返回答案给父问题</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 98. Validate Binary Search Tree</title>
      <link href="/2021/07/16/LeetCode%2098.%20Validate%20Binary%20Search%20Tree/"/>
      <url>/2021/07/16/LeetCode%2098.%20Validate%20Binary%20Search%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol><li><p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node’s key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul></li></ol><p><a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – DFS, bottom up</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root, <span class="keyword">long</span> minVal, <span class="keyword">long</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt;= maxVal || root.val &lt;= minVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, minVal, root.val) &amp;&amp; isValidBST(root.right, root.val, maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bottom up </tag>
            
            <tag> DFS(tree) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 450. Delete Node in a BST</title>
      <link href="/2021/07/15/LeetCode%20450.%20Delete%20Node%20in%20a%20BST/"/>
      <url>/2021/07/15/LeetCode%20450.%20Delete%20Node%20in%20a%20BST/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol><p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">https://leetcode.com/problems/delete-node-in-a-bst/</a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(key &lt; root.val) root.left = deleteNode(root.left, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; root.val) root.right = deleteNode(root.right, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root.val = findMin(root.right);</span><br><span class="line">            root.right = deleteNode(root.right, root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(logn)</p><p>Space complexity: O(H)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> delete node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 426. Convert Binary Search Tree to Sorted Doubly Linked List</title>
      <link href="/2021/07/14/LeetCode%20426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/"/>
      <url>/2021/07/14/LeetCode%20426.%20Convert%20Binary%20Search%20Tree%20to%20Sorted%20Doubly%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Convert a <strong>Binary Search Tree</strong> to a sorted <strong>Circular Doubly-Linked List</strong> in place.</p><p>You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p><p>We want to do the transformation <strong>in place</strong>. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.</p><p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,2,5,1,3]</span><br><span class="line">Output: [1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [1,2,3]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node pre = <span class="keyword">null</span>, head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">treeToDoublyList</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        inorderTraversal(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorderTraversal(root.left); <span class="comment">//left</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) head = root;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="keyword">null</span>) pre.right = root; <span class="comment">//root</span></span><br><span class="line">        root.left = pre;</span><br><span class="line">        pre = root;</span><br><span class="line">        inorderTraversal(root.right); <span class="comment">//right</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> Convert tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link href="/2021/07/13/LeetCode%20106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/"/>
      <url>/2021/07/13/LeetCode%20106.%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two integer arrays <code>inorder</code> and <code>postorder</code> where <code>inorder</code> is the inorder traversal of a binary tree and <code>postorder</code> is the postorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inorder = [-1], postorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – postorder traversal, inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    Map&lt;Integer, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.postorder = postorder;</span><br><span class="line">        N = inorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) inMap.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, N - <span class="number">1</span>, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> inStart, <span class="keyword">int</span> inEnd, <span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postEnd]);</span><br><span class="line">        <span class="keyword">int</span> inIndex = inMap.get(root.val);</span><br><span class="line">        <span class="keyword">int</span> rightTreeSize = inEnd - inIndex;</span><br><span class="line">        root.left = helper(inStart, inIndex - <span class="number">1</span>, postStart, postEnd - rightTreeSize -<span class="number">1</span>);</span><br><span class="line">        root.right = helper(inIndex + <span class="number">1</span>, inEnd, postEnd - rightTreeSize, postEnd -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2021/07/12/LeetCode%20105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/"/>
      <url>/2021/07/12/LeetCode%20105.%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal, inorder</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">int</span>[] inorder;</span><br><span class="line">    <span class="keyword">int</span> preOrderIndex;</span><br><span class="line">    Map&lt;Integer, Integer&gt; treeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">this</span>.inorder = inorder;</span><br><span class="line">        <span class="keyword">this</span>.preOrderIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = preorder.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) treeMap.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> helperbulid(<span class="number">0</span>, N-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helperbulid</span><span class="params">(<span class="keyword">int</span> instart, <span class="keyword">int</span> inend)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instart &gt; inend) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[preOrderIndex++]);</span><br><span class="line">        <span class="keyword">int</span> index = treeMap.get(root.val);</span><br><span class="line">        root.left = helperbulid(instart, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helperbulid(index + <span class="number">1</span>, inend);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 1008. Construct Binary Search Tree from Preorder Traversal</title>
      <link href="/2021/07/11/LeetCode%201008.%20Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/"/>
      <url>/2021/07/11/LeetCode%201008.%20Construct%20Binary%20Search%20Tree%20from%20Preorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given an array of integers preorder, which represents the <strong>preorder traversal</strong> of a BST (i.e., <strong>binary search tree</strong>), construct the tree and return <em>its root</em>.</p><p>It is <strong>guaranteed</strong> that there is always possible to find a binary search tree with the given requirements for the given test cases.</p><p>A <strong>binary search tree</strong> is a binary tree where for every node, any descendant of <code>Node.left</code> has a value <strong>strictly less than</strong> <code>Node.val</code>, and any descendant of <code>Node.right</code> has a value <strong>strictly greater than</strong> <code>Node.val</code>.</p><p>A <strong>preorder traversal</strong> of a binary tree displays the value of the node first, then traverses <code>Node.left</code>, then traverses <code>Node.right</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [8,5,1,7,10,12]</span><br><span class="line">Output: [8,5,10,1,7,null,12]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [1,3]</span><br><span class="line">Output: [1,null,3]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index, N;</span><br><span class="line">    <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == N) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = preorder[index];</span><br><span class="line">        <span class="keyword">if</span> (val &lt; lower || val &gt; upper) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        index ++;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = helper(lower, val);</span><br><span class="line">        root.right = helper(val, upper);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        N = preorder.length;</span><br><span class="line">        <span class="keyword">return</span> helper(Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Construct tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 449. Serialize and Deserialize BST</title>
      <link href="/2021/07/10/LeetCode%20449.%20Serialize%20and%20Deserialize%20BST/"/>
      <url>/2021/07/10/LeetCode%20449.%20Serialize%20and%20Deserialize%20BST/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Serialization is converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a <strong>binary search tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You need to ensure that a binary search tree can be serialized to a string, and this string can be deserialized to the original tree structure.</p><p><strong>The encoded string should be as compact as possible.</strong></p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [2,1,3]</span><br><span class="line">Output: [2,1,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String res = String.valueOf(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) res += <span class="string">&quot;,&quot;</span> + serialize(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) res += <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> deserialize(q, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(Queue&lt;String&gt; q, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String s = q.peek();</span><br><span class="line">        <span class="keyword">int</span> val = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; lower || val &gt; upper) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        q.poll();</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = deserialize(q, lower, val);</span><br><span class="line">        root.right = deserialize(q, val, upper);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Serialize and Deserialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 297. Serialize and Deserialize Binary Tree</title>
      <link href="/2021/07/09/LeetCode%20297.%20Serialize%20and%20Deserialize%20Binary%20Tree/"/>
      <url>/2021/07/09/LeetCode%20297.%20Serialize%20and%20Deserialize%20Binary%20Tree/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Clarification:</strong> The input/output format is the same as <a href="https://leetcode.com/faq/#binary-tree">how LeetCode serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,null,4,5]</span><br><span class="line">Output: [1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – preorder traversal</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> root.val + <span class="string">&quot;,&quot;</span> + serialize(root.left) + <span class="string">&quot;,&quot;</span> + serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> helper(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(Queue&lt;String&gt; q)</span></span>&#123;</span><br><span class="line">        String s = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;#&quot;</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(s));</span><br><span class="line">        root.left = helper(q);</span><br><span class="line">        root.right = helper(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> Serialize and Deserialize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 103. Binary Tree Zigzag Level Order Traversal</title>
      <link href="/2021/07/08/LeetCode%20103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/"/>
      <url>/2021/07/08/LeetCode%20103.%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the zigzag level order traversal of its nodes’ values</em>. (i.e., from left to right, then right to left for the next level and alternate between).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[20,9],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) level.add(cur.val);</span><br><span class="line">                <span class="keyword">else</span> level.add(<span class="number">0</span>, cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 107. Binary Tree Level Order Traversal II</title>
      <link href="/2021/07/07/LeetCode%20107.%20Binary%20Tree%20Level%20Order%20Traversal%20II/"/>
      <url>/2021/07/07/LeetCode%20107.%20Binary%20Tree%20Level%20Order%20Traversal%20II/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – BFS</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 102. Binary Tree Level Order Traversal</title>
      <link href="/2021/07/06/LeetCode%20102.%20Binary%20Tree%20Level%20Order%20Traversal/"/>
      <url>/2021/07/06/LeetCode%20102.%20Binary%20Tree%20Level%20Order%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes’ values</em>. (i.e., from left to right, level by level).</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [[1]]</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> traversal </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 145. Binary Tree Postorder Traversal</title>
      <link href="/2021/07/04/LeetCode%20145.%20Binary%20Tree%20Postorder%20Traversal/"/>
      <url>/2021/07/04/LeetCode%20145.%20Binary%20Tree%20Postorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the postorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [3,2,1]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2]</span><br><span class="line">Output: [2,1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(<span class="number">0</span>, root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 94. Binary Tree Inorder Traversal</title>
      <link href="/2021/07/03/LeetCode%2094.%20Binary%20Tree%20Inorder%20Traversal/"/>
      <url>/2021/07/03/LeetCode%2094.%20Binary%20Tree%20Inorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the inorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,3,2]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 144. Binary Tree Preorder Traversal</title>
      <link href="/2021/07/02/LeetCode%20144.%20Binary%20Tree%20Preorder%20Traversal/"/>
      <url>/2021/07/02/LeetCode%20144.%20Binary%20Tree%20Preorder%20Traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes’ values</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,null,2,3]</span><br><span class="line">Output: [1,2,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = []</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><ul><li>Solution1 – iterative</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>) stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) stack.push(root.right);</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) stack.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p><ul><li>Solution2 – recursive</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        helper(root.left, res);</span><br><span class="line">        helper(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Complexity:</p><p>Time complexity: O(n)</p><p>Space complexity: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
          <category> Tree </category>
          
      </categories>
      
      
        <tags>
            
            <tag> recursive </tag>
            
            <tag> traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论兴趣</title>
      <link href="/2021/01/01/%E8%AE%BA%E5%85%B4%E8%B6%A3/"/>
      <url>/2021/01/01/%E8%AE%BA%E5%85%B4%E8%B6%A3/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>写下这篇文章是想说说我对专业与兴趣之间的关系的看法。当我们大学选专业的时候，当我们研究生选方向的时候，当我们博士选方向的时候，当我们工作选岗位的时候，都会很疑惑到底哪个方向更适合自己。询问了一堆前辈后，有的告诉你要根据前景选，有的告诉你要根据兴趣选，最后困扰我们的问题就变成了，到底是选一个自己感兴趣的方向还是选一个前景好的方向？这个问题就是本文主要想讨论的一个问题。</p><p>面对一个问题，我们先要来深入了解一下，这个问题的本质是什么。所以，我想先说说我对兴趣的看法。我对兴趣的看法始终都是：<strong>不要把兴趣看得多么崇高，你做的好你就感兴趣，你做的不好你就不感兴趣。</strong></p><span id="more"></span><p>拿大学选专业做个例子，很大一部分人会选择化学类的专业的原因就是因为他们高中化学学的非常好，有的化学不怎么学就一直考满分，有的参加过各种竞赛拿到了金奖。这种经历给他们一种感觉，我化学学的非常好所以我对化学是有天分的。同时，因为他们的化学成绩好，周围的同学和老师时不时的称赞更增强了这种感觉。</p><p>于是，这群人就选了化学作为大学专业，可是等到了大学，其中的一部分人却发现化学学起来没那么简单了，慢慢的他们再也找不到当初高中时周围人一直称赞的感觉，每门科目都学的很吃力，这时候你猜他们对化学还感兴趣吗？</p><p>还有一部分人，大学化学依然学的很好，这群人依然活在他人的称赞中，在完成了基本的课业后，还有余力去实验室做做实验，可是等这群人去了实验室之后发现，做实验没有自己想的那么有趣。大部分的实验都是机械的重复，再强的通风橱也不能完全挡住化学药品的味道，每天机械的重复过柱子，收集产物，有些动手能力稍微差点的人还会时不时打碎些仪器，在师兄师姐的注视中窘迫的打扫着碎掉的仪器，这时候你猜他们对化学还感兴趣吗？</p><p>还有一部分人，大学成绩还可以，做实验也不错，跟着师兄师姐们混到了文章或者自己发出来文章，又受到了周围人的称赞，于是这部分人认为自己对于化学真的有天分，继续往下读研、读博。刚到了新环境，一开始这部分人发现做实验很简单，随便做做电极材料，组组电池，测测性能，一套表征，一篇文章就出来了。于是，换种材料，继续相同的操作，相同的实验操作，然后再换材料，不断的重复，这个时候他们感觉自己每天像个机器一样，重复做着没啥用的东西，目的只是为了发出一些很难创造生产力的paper。然后，你似乎无意间发现你以前的同学已经在某歌，某书，某鹅，某字公司拿了几十万的package，你也开始考虑自己以后的工作，看着各种高校青椒的招聘要求和一言难尽的工资，以及各种论坛青椒们吐槽的压力，再看看不断上涨的房价，用这些工资在稍微好一点的城市买个厕所都难，这时候你猜他们对化学还感兴趣吗？</p><p>当然，还有一部分人，他们做的研究是开创性的，是具有划时代意义的，是真正沉下心来搞研究的，他们慢慢的做着研究，享受着研究。半夜想到了新的点子，会忍不住爬起来，跑去实验室尝试自己的新想法。毫无疑问，这部分人才是真正的热爱化学。可是，能做到这样的人，又有多少呢？</p><p>所以，我一直觉得，<strong>兴趣就是你做的好你就有兴趣，没什么神秘的。</strong></p><p>当明确了兴趣对于大多数人来说意味着什么，我们的问题就可以进入下一阶段了。做的好就有兴趣这种特征，给了兴趣很大的可塑造性。我们的幸福感是由一个又一个的正反馈组成。你可以选择一个有前景的方向，并把那个方向培养成你兴趣，当你选择一个有前景的方向时，你会发现你能更加容易的获得这一个又一个的正反馈，最终可以更容易实现快乐生活，快乐工作。</p><p>那么，如何选择一个有前景的方向的就变成了一个新的问题。这个问题有一个通用解，不过通用解也有些弊端，相关细节某乎上一搜一大堆，在这里不做过多的阐述，我们来聊些别的。</p><p>马克思说：“<strong>人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和</strong>”。人是一种社会性的生物，仅靠自己很难生活下去，我们必定要和这个社会产生联系。一个社会的发展会有他的大趋势，如果我们可以让我们的方向趋于社会发展的方向，那样做起事才会事半功倍。这也就是人们常说的，坐在风口上猪都能飞起来。那种两耳不闻窗外事，一心只读圣贤书的生活已经极度不适合当下的社会。</p><p>拿一艘在奔流的河道中前行的船举个例子，河流的方向就是社会发展的方向，我们就是这一艘艘船，我们的能力就是船的动力，努力就是向船中加入更大的燃料，获得更大的动力，选择就是掌舵，控制船前行的方向。当我们控制船前行的方向和河流的方向一致时，你会发现你不怎么用力就可以前行的很快，当我们前行的方向不一致时，我们需要更多的努力才能和上一种情况的船具备相同的速度。选择和努力的区别，个人方向和社会方向的统一性与差异性就在这里。</p><p>接下来，我想来谈一个和我们常识有些不一样的问题。那就是，我们一直选择我们认为的最优的方案，最后的结果是不是最优？这个问题也可以抽象成一个数学问题，<strong>贪心算法能不能得到全局最优解？</strong>和大部分人认知不一样的是，如果我们每一步都是最优解，这个结果会将我们导向一个局部最优解，我们大多数的时候是得不到全局最优解的。就像下图所示一样。</p><img src="https://raw.githubusercontent.com/MrainW/Markdown-Photos/master/Photos/Picture1.png" alt="Picture1" style="zoom:50%;" /><p>如果我们经常交流的是和自己所处环境类似的人，或者向他们请教经验，这些经验只是会加快我们走向局部最优解的速度，并不能帮助我们导向其他更好的解。因为我们的处在相似的环境，在类似的环境下，我们的想法也趋于一致。</p><p>比如说，某合成实验室的新生张三，某一天向他的师兄请教哪个方向适合作为博士的开题方向，张三的师兄耐心的给他分析了，方案一只是机械的在本体上接了一个甲基，创新性不够，方案二虽然只是多合成了几个碳链，但是却可以在溶剂里自组装成胶束，方案二更新颖一点。当张三回到家里和他隔壁实验室的舍友交流时，他的舍友告诉他，你们老板不是还有一个电催化的大课题，你去做那个方向啊，电催化实验周期短，不用苦逼的合成过柱子，你发一篇合成的文章的功夫都够发两篇电催化的文章了。或许，当张三和他的金融系同学，医学院同学和计算机学院的同学交流时又会得到不同的回答。</p><p>当我们交流的对象都是和我们处于同一环境的人的时候，我们很难跳出这个局部最优解。你认为的所采取的解决方案，反而很大可能加快了你走向局部最优解的过程。同时，走向这个局部最优解的过程，你得到的正反馈是会越来越多的，你是会有你变得越来越幸福的感觉。只有当某一天，你真正的遇到了在这个局部最优解无所解决的问题，你才会意识到自己到了这个局部最优解。我们的想法和思维方式大多都来源于后天的学习，环境对我们的影响非常大，一直处于一种类型的环境会极大的限制住我们的思维，最终将你自己关在监狱里的正是你自己。</p><p>突破这种思维的僵局的一种非常有效的方式就是开源。你要多和不同领域的人交流，了解不同领域的知识，这些会帮助你确定一个导向更优的解的方向。然后你再努力，努力是加速你到达你确定的那个最优解的基本要求，选择则是帮助你确定一个比较好的解。</p><p>其实这些对于很多人都明白，只是人很喜欢待在自己所处的舒适区，不愿意改变。就像<strong>电磁感应现象</strong>一样，总是阻碍着变化。人又和一些基本的物理定律统一了，这或许也是我们来源世界，没有啥特殊性的一种表现。</p><p>这篇文章只是我在现阶段的一些感想，本来也只是提供一种思维的方式，人总是会变的，就像《平凡的世界》里的张有智和周文龙，一个由好变坏，一个由坏变好，我们终究是需要用变化的眼光看待所有的事。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园三</title>
      <link href="/2020/08/20/%E5%A4%A7%E8%A7%82%E5%9B%AD3/"/>
      <url>/2020/08/20/%E5%A4%A7%E8%A7%82%E5%9B%AD3/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>五年前。</p><p>小楼无聊的在床上刷着手机，不时发出阵阵笑声。</p><p>“大威天龙，世尊地藏，般若诸佛，般若巴嘛空。“</p><p>“三年之期已到！恭迎龙王√“</p><p>“生不出人，我很抱歉“</p><p>“人在美国，刚下飞机”</p><p>“。。。。。。”</p><p>“嗡嗡嗡”</p><span id="more"></span> <p>忽然一封邮件打破了他的欢乐，他迟疑了一会，慢慢的拿起来旁边的手机，心剧烈的跳动着，然后他深吸了口气，打开了屏保，狠下心来，点开了那封邮件——原来只是个广告。</p><p>虚惊一场！</p><p>没等他放下手机，又一封邮件发过来了，他顺手打开了那封邮件，短暂的沉默后，他嘴角露出了一丝微笑。小楼终于收到了他梦寐以求的公司的offer。他曾经幻想着，当自己成功进入那家公司后，自己会多么激动，可真正发生后，有的只是平静。</p><p>很多人都喜欢小狗，但是有些人本身却对小狗过敏，不能接触小狗，机器狗的出现就完美的解决了这个问题。在当今的时代，人们已经可以制造出，和真实的狗非常相似的机器狗了。</p><p>这种机器狗不只智力和外表与普通的狗相同，更惊人的是他们不会衰老，可以陪伴你一生。但是机器狗也会损坏，正常的狗生病会去宠物医院，他们损坏时就要去专门的机器狗宠物医院去维修。</p><p>小楼的工作就是维修坏掉的机器狗。</p><p>第一次见到机器狗，小楼很吃惊，他们摸上去和正常的狗完全一样，还不会掉毛。甚至连摸他的反应也和正常的狗一样。小楼根本分不出哪些是正常的狗，哪些是机器狗。</p><p>小楼维修的第一只宠物狗是一位老奶奶的，宠物狗的名字叫家宝，和老奶奶的孩子同名。老奶奶自己一个人住在家里，她的老伴和孩子在多年前的一场席卷全球的冠状病毒中去世了，这么多年来就只有家宝陪伴着她了。他会陪着老奶奶看电视，陪着老奶奶散步，陪着老奶奶去超市，家宝就是老奶奶所有的精神支柱了。</p><p>小楼永远都忘不了，老奶奶抱着碎裂的家宝躯体来宠物医院的那一天，老奶奶用颤抖的声音求着小楼一定要治好家宝，小楼望着老奶奶湿润的双眼，郑重的承诺一定会治好家宝。</p><p>望着已经碎成好几段的家宝，小楼从心脏的位置取出了家宝的芯片，这个芯片就是家宝与老奶奶所有的记忆。这些记忆其实就是一个又一个的程序，家宝和老奶奶的每一次交流都会改变程序的参数或者产生新的程序，这些程序就全部储存在芯片中，组成了家宝的记忆。</p><p>小楼看着已经裂开的芯片，从仓库中取出一个新的芯片，将旧芯片的数据全部拷贝到新芯片中，</p><p>然后将芯片插入到另一只和家宝型号一样的机器狗体内，那样这个新的机器狗就继承了家宝全部的记忆，并拥有和家宝一样的外貌。</p><p>小楼刚启动了新家宝，家宝就迅速跑出去，一溜烟的扑向了老奶奶的怀里，老奶奶紧紧抱着怀里的家宝，激动的热泪盈眶。</p><p>望着老奶奶怀里的家宝，小楼不禁产生了一个疑问，他和碎成渣的旧家宝到底哪个是家宝，新家宝身上没有一个零件是来自旧家宝，甚至连承载记忆的芯片都是新的，只有拷贝过来的记忆是旧家宝的。</p><p>看着老奶奶激动的样子，小楼终究还是没有把心里的想法告诉老奶奶。</p><p>回到修理室，小楼默默的把残缺家宝的遗体，带去医院后山埋了起来，感谢旧家宝陪伴了老奶奶这么久，就让这只忒修斯之狗长眠于此把。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园二</title>
      <link href="/2020/05/18/%E5%A4%A7%E8%A7%82%E5%9B%AD2/"/>
      <url>/2020/05/18/%E5%A4%A7%E8%A7%82%E5%9B%AD2/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>轰隆隆, 飞机终于起飞了。下面的房屋越来越远，渐渐消失在视野中。</p><p>大痣一上飞机就闭上了眼睛，身体似乎还有些发抖。小楼在旁边看着大痣，嘴角露出了一丝坏笑。大痣虽然什么都看得都比小楼透彻，但就是害怕坐飞机。偏偏大痣每次都嘴硬的说自己完全不怕，只是感觉飞机的冷气开的太足了，自己是被冻的发抖。每每看到大痣这个样子，小楼总会很开心，虽然他什么都不如大痣，但至少在这一点他觉得自己终于胜过大痣了。</p> <span id="more"></span><p>不再去管大痣，小楼打望着周围。</p><p>座位前方是一位带着孩子的年轻妈妈，小孩子奶声奶气的想让妈妈给她讲故事；不远处是一位面色蜡黄的老爷爷，老爷爷似乎是得了什么病，不时发出一阵阵压抑着的呻吟；后面是一对恩爱的情侣，那位男生不知道说了什么，惹得女生娇羞的用手轻打着男生，男生则满脸洋溢着宠溺的笑。</p><p>小楼很喜欢静静的看着周围发生的这些，他感到这些充满着生活的气息，喜怒哀乐在同一场景呈现着，每个人都有自己独特的地方，这些画面会让他感到很平和。</p><p>深吸一口气，他感到生活充满着希望。</p><p>收回目光，小楼拿出了一副耳塞一样的东西，通体呈银色，两边有些斑驳的黄点，顶端有一行蓝色的小字，细细看去正是大观园这三个字。看到这三个字的时候，小楼忍不住吐槽，这家公司有点意思啊，这是在嘲笑我们都是刘姥姥吗？</p><p>说起这大观园，这是一家很奇幻的科技公司，据说这是全球所有国家共同建立起的一家公司，这家公司成立的目的只有一个——探寻人类最终的归宿。每个国家将自己收集来的全部历史数据无偿的提供给这家公司，这家公司便利用了这些数据，建立了很多模拟的世界，从宇宙大爆炸开始，以远超于现实世界的速度进化着，想借此探寻人类最终的归宿在哪里，人类存在的意义是什么。</p><p>而大观园则是这家公司众多模拟世界里最成功的一个。最惊奇的是，通过那银色的耳塞，你甚至可以把自己的意识上传到大观园，以观察者的身份暂居在大观园内的虚拟生命体上。</p><p>“嗖啦”</p><p>小楼带上了耳塞，缓缓闭上了眼睛，进入了大观园。</p><p>再睁开眼，小楼发现自己来到了一间石头堆砌的小房子，很简陋，墙上挂满着各种石磨的武器，还有很多动物皮一样的东西。房子中央是一个木头搭起来的小桌子，桌子上还有石制的容器，里面装满着水。在一个角落里，是一个堆砌的石堆，里面竟然是燃烧后的木头。小楼感到一切惊奇，大观园才刚演化100年，竟然已经发展到可以生火，造房屋了，真是神奇。</p><p>再看向自己寄居的模拟体，是一个狮子摸样的模拟体，正在休息。狮子的尾巴已经消失不见了，前脚演化成像人类手掌一样，手心还有厚厚的肉垫，肚子鼓鼓的，显得胖嘟嘟的。身上依然是毛绒绒的，可可爱爱。</p><p>小楼心想：原来这个模拟世界的“人类”竟然是狮子演变来的吗。</p><p>小楼想用手去摸摸他手掌的肉球，可是发现自己什么也做不了。</p><p>这是大观园公司做的限制，为了不让外来的观察者改变这里的演化，所有进来的人，都只能是观察者。小楼感觉到有些失望，自己好不容易才得到的大观园测观察者的资格竟然只能做到这些。</p><p>忽然，小楼寄居的狮子要醒过来了。小楼正处于刚才失望的心情中，就想捉弄一下他。就用意念强制不让狮子醒过来，他可以感受到狮子的意识是清醒的，但是却失去了对身体的控制权。只能躺在石头床上，一动不动。感受到狮子惊恐的意识，小楼内心有种诡计得逞的窃喜。</p><p>渐渐的，狮子意识越来越清醒，小楼越来越压抑不住狮子的行为。一个不留神，身体的控制权就被狮子夺回去了。</p><p>狮子猛的从石床上跳起来，大口的喘着粗气。眼中充满恐惧，一阵后怕。</p><p>狮子想起，在自己小的时候曾听自己的妈妈讲过她之前也有过类似的经历，意识清醒却怎么也醒不过来，就像被鬼压在身上一样。当时他还以为自己的妈妈只是为了吓唬他，可以让他多出去狩猎锻炼一下，不要老待在石屋里睡觉，没想到今天自己竟然真的遇到了。</p><p>他还记得他的妈妈把这种经历叫做——鬼压床。</p><p>感受到狮子刚才的想法，小楼内心涌出一股寒意，他想起自己曾经也有过好多次鬼压床的经历。但随即他又摇摇头，压下自己突然出现的不切实际的想法。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大观园一</title>
      <link href="/2020/05/04/%E5%A4%A7%E8%A7%82%E5%9B%AD1/"/>
      <url>/2020/05/04/%E5%A4%A7%E8%A7%82%E5%9B%AD1/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>“大痣，大痣，愣在那干什么呢，快走了，要赶不上回家的飞机了！”</p><p>恍惚中被惊醒的的大痣，快步追了上去。其实大痣本名并不叫大痣，他名叫吴用。只是大痣眼角有一颗痣，大家便大痣大痣的叫了下来。</p><p>说起这大痣，他小时候却有另一个外号，没错，就是智多星吴用。那时的他勤奋好奇，博古通今，倒也真对得住这称呼。在他小学时，有次年级大会，有位学校重金聘请过来的国学大师，在台上“指点江山，激扬文字”，他实在听不下去了，直接走上台去，在全年级的同学的一阵惊呼中，指出了他刚才讲的19个错误。全场一片哗然，然后他就像个没事人似的默默的走下了台，只留下身后阵阵的掌声。虽然那件事后，他就被叫去谈话了，但大家都知道他不会变的，吴用就是吴用，要是这么通人情，懂变通，也不会只有小楼一个朋友了。</p><span id="more"></span><p>小楼是大痣唯一的一个朋友，他们从小学就是朋友了，一直到后来工作，他们也都是朋友，他见证着大痣从天才到“平庸”的变化。小楼和大痣不同，他是典型的乖学生，从不迟到早退，从不顶撞老师，在家听父母的话，在外尊敬师长。为数不多的几次“造反”经历，全是被大痣蛊惑的。大痣总调侃他，生活过的像你这样规规矩矩，一眼就忘得见未来，还有什么意思。学习时只知道学习，工作后只为了赚钱，你的人生到底是为什么活着的？小楼则总是不甘示弱的回复到，要是像你一样活着，我出门早就被人乱棍打死了，现在坟头草都一丈多了，你放心你死后不会寂寞的，我会每天都去你坟头蹦迪的。</p><p>不过在夜深人静的时候，小楼也总会去想大痣的话。他越来越感觉到自己的生活过的很平淡，他不知道自己到底是为了什么活下去的。他想起，自己小时候班里的老师问学生，你们以后的梦想是什么？有的回答周游世界，有的回答想当老师，有的想当超人，他记得自己当时回答说想当科学家，去探索世界的奥秘。可是他知道，那只是因为自己害怕其他人都有梦想，自己啥都没有而胡乱编出来的。他不像大痣，能把一切都看的很透彻，他只是个普通人。</p><p>有次大痣问小楼，你听过那个细铁链拴大象的故事吗？小楼说，我听过啊，不就是一只大象从小就被细铁链栓住，虽然现在它已经有足够的力气挣脱它了，但是无形的锁链依然禁锢着它。那你觉得你和这个大象有什么区别？小楼突然感觉心里一颤，他感到自己内心最柔软的地方突然被刺了一下。大痣继续说，我告诉你，没有区别，相反我觉得你比那大象更可怜。虽然你看不到，但你身上无形的铁链，已经把你紧紧的束缚住了。每个人从一开始，都是一张白纸，从一出生后，我们就开始被无形的铁链缠绕的一生了。这些铁链你看不到，但却限制着你的行为，像把你关进了监狱，一座你永远也逃不出的监狱。你想要的，你所认为自由的思想，你所谓的价值观，你所追求的理想的生活，全都是别人告诉你的，其实你只是一张被社会用过的打草纸罢了。</p><p>小楼感到自己被一种不知名的情绪包裹着，他看着大痣，缓缓的低下了头。</p><p>再回过神，大痣已经走远了，只留下一句随风飘来的话，小楼别怪我，一句话语只有刺痛你内心最软弱的地方才会改变你，我不想你浑浑噩噩的活下去。</p><hr><h2 id="交个朋友"><a href="#交个朋友" class="headerlink" title="交个朋友"></a>交个朋友</h2><ul><li>个人微信公众号：miaoyuwangyan</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小说 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大观园 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
